{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-sortable-tree.js","webpack:///webpack/bootstrap 5efe8a9c500e9b782d22","webpack:///./src/index.js","webpack:///./src/utils/tree-data-utils.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///external \"react\"","webpack:///./src/utils/default-handlers.js","webpack:///./src/utils/drag-and-drop-utils.js","webpack:///./src/item-types.js","webpack:///./src/node-renderer-default.js","webpack:///./src/react-sortable-tree.js","webpack:///./src/tree-node.js","webpack:///./src/utils/browser-utils.js","webpack:///./src/utils/generic-utils.js","webpack:///./~/react-virtualized/styles.css","webpack:///./src/node-renderer-default.scss","webpack:///./src/react-sortable-tree.scss","webpack:///./src/tree-node.scss","webpack:///./~/react-virtualized/styles.css?8e78","webpack:///./src/node-renderer-default.scss?77d4","webpack:///./src/react-sortable-tree.scss?6d9e","webpack:///./src/tree-node.scss?9630","webpack:///external \"lodash.isequal\"","webpack:///external \"react-dnd\"","webpack:///external \"react-dnd-html5-backend\"","webpack:///external \"react-virtualized\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_4__","__WEBPACK_EXTERNAL_MODULE_21__","__WEBPACK_EXTERNAL_MODULE_22__","__WEBPACK_EXTERNAL_MODULE_23__","__WEBPACK_EXTERNAL_MODULE_24__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_defaultHandlers","keys","forEach","key","enumerable","get","_treeDataUtils","_reactSortableTree","_reactSortableTree2","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","undefined","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","treeIndex","children","expanded","nextIndex","childIndex","childCount","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$path","_ref3$lowerSiblingCou","selfInfo","callbackResult","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$path","_ref4$lowerSiblingCou","newChildren","map","child","mapResult","getVisibleNodeCount","_ref5","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_extends","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","getNodeAtPath","_ref15","_ref15$ignoreCollapse","foundNodeInfo","_ref16","err","addNodeUnderParent","_ref17","_ref17$parentKey","parentKey","_ref17$ignoreCollapse","_ref17$expandParent","expandParent","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref18","parentNode","addNodeAtDepthAndIndex","_ref19","targetDepth","minimumTreeIndex","_ref19$isPseudoRoot","isLastChild","currentDepth","extraNodeProps","insertIndex","insertNode","_ref20","depth","_ref20$ignoreCollapse","_ref20$expandParent","insertResult","getFlatDataFromTree","_ref21","_ref21$ignoreCollapse","flattened","_ref22","push","getTreeFromFlatData","_ref23","flatData","getKey","getParentKey","rootKey","childrenToParents","trav","parent","isDescendant","older","younger","some","getDepth","arguments","deepest","Math","max","find","_ref24","searchQuery","searchMethod","searchFocusOffset","_ref24$expandAllMatch","expandAllMatchPaths","_ref24$expandFocusMat","expandFocusMatchPaths","matchCount","_ref25","_ref25$isPseudoRoot","_ref25$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","assign","target","source","prototype","hasOwnProperty","list","toString","item","join","mediaQuery","alreadyImportedModules","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","removeStyleElement","removeChild","idx","indexOf","splice","createStyleElement","document","createElement","type","createLinkElement","linkElement","rel","update","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","memoize","fn","memo","apply","isOldIE","test","window","navigator","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","defaultGetNodeKey","getReactElementText","_typeof","props","stringSearch","String","defaultSearchMethod","Symbol","iterator","constructor","getTargetDepth","dropTargetProps","monitor","dropTargetDepth","draggedItem","getItem","rowAbove","getPrevRow","min","blocksOffset","round","getDifferenceFromInitialOffset","x","scaffoldBlockPxWidth","maxDepth","draggedNode","draggedChildDepth","canDrop","isHover","abovePath","aboveNode","nodeDragSourcePropInjection","connect","connectDragSource","dragSource","connectDragPreview","dragPreview","isDragging","nodeDropTargetPropInjection","dragged","connectDropTarget","dropTarget","isOver","scrollDropTargetPropInjection","_connectDropTarget","dndWrapSource","el","_reactDnd","DragSource","_itemTypes2","HANDLE","nodeDragSource","dndWrapTarget","DropTarget","nodeDropTarget","dndWrapRoot","DragDropContext","_reactDndHtml5Backend2","scrollDropTarget","_reactDndHtml5Backend","_itemTypes","beginDrag","startDrag","endDrag","getDropResult","dropTargetNode","drop","hover","dragHover","listIndex","component","_this","cancelAnimationFrame","timeout","clearTimeout","requestAnimationFrame","func","setTimeout","lastScroll","removeTimeout","slideRegionSize","_monitor$getClientOff","getClientOffset","dragXOffset","dragYOffset","y","_component$containerR","containerRef","getBoundingClientRect","containerTop","top","containerBottom","bottom","containerLeft","left","containerRight","right","yScrollDirection","yScrollMagnitude","fromTop","sqrt","fromBottom","innerHeight","xScrollDirection","xScrollMagnitude","fromLeft","ceil","fromRight","innerWidth","doScroll","scrollBy","_react","_react2","_browserUtils","_nodeRendererDefault","_nodeRendererDefault2","getIEVersion","row","row_NoFlex","rowContents","rowContents_NoFlex","rowLabel","rowLabel_NoFlex","rowToolbar","rowToolbar_NoFlex","NodeRendererDefault","toggleChildrenVisibility","isSearchMatch","isSearchFocus","buttons","className","_ref$style","style","handle","loadingHandle","loadingCircle","loadingCirclePoint","moveHandle","dropEffect","isDraggedDescendant","height","collapseButton","expandButton","onClick","width","lineChildren","rowWrapper","rowLandingPad","rowCancelPad","rowSearchMatch","rowSearchFocus","opacity","rowTitle","subtitle","rowTitleWithSubtitle","title","rowSubtitle","btn","toolbarButton","propTypes","PropTypes","object","isRequired","arrayOf","oneOfType","string","number","bool","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","descriptor","protoProps","staticProps","_reactVirtualized","_lodash","_lodash2","_treeNode","_treeNode2","_genericUtils","_dragAndDropUtils","ReactSortableTree","_Component","getPrototypeOf","nodeContentRenderer","state","draggingTreeData","swapFrom","swapLength","swapDepth","rows","getRows","searchMatches","searchFocusTreeIndex","scrollToPixel","moveNode","loadLazyChildren","search","ignoreOneTreeUpdate","targetNode","onChange","onVisibilityToggle","onMoveNode","nextProps","setState","seekIndex","expand","singleSearch","searchFinishCallback","_find","expandedTreeData","addedResult","expandedParentPath","swapTo","swapRows","dropResult","_this2","loadCollapsedLazyChildren","done","childrenArray","oldNode","getElementsByClassName","virtualScrollOverride","scrollLeft","scrollTop","_this3","_props","innerStyle","rowHeight","_state","matchKeys","scrollToInfo","scrollToIndex","tree","ref","AutoSizer","List","scrollToAlignment","onScroll","rowCount","estimatedRowSize","rowRenderer","rowStyle","renderRow","reactVirtualizedListProps","NodeContentRenderer","nodeKey","nodeProps","generateNodeProps","Component","any","defaultProps","_objectWithoutProperties","TreeNode","otherProps","scaffoldBlockCount","scaffold","lowerSiblingCount","lineClass","lineHalfHorizontalRight","lineHalfVerticalBottom","lineFullVertical","lineHalfVerticalTop","lineBlock","highlightLineClass","highlightBottomLeftCorner","highlightTopLeftCorner","highlightLineVertical","absoluteLineBlock","nodeContent","Children","cloneElement","array","parseInt","fromIndex","toIndex","count","rowsWithoutMoved","locals","pointFade","visibilityToggleButton","arrow-pulse","content"],"mappings":"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","file":"react-sortable-tree.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-virtualized\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"lodash.isequal\", \"react-dnd\", \"react-dnd-html5-backend\", \"react-virtualized\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactSortableTree\"] = factory(require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-virtualized\"));\n\telse\n\t\troot[\"ReactSortableTree\"] = factory(root[\"react\"], root[\"lodash.isequal\"], root[\"react-dnd\"], root[\"react-dnd-html5-backend\"], root[\"react-virtualized\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_21__, __WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_23__, __WEBPACK_EXTERNAL_MODULE_24__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-virtualized\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"lodash.isequal\", \"react-dnd\", \"react-dnd-html5-backend\", \"react-virtualized\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactSortableTree\"] = factory(require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-virtualized\"));\n\telse\n\t\troot[\"ReactSortableTree\"] = factory(root[\"react\"], root[\"lodash.isequal\"], root[\"react-dnd\"], root[\"react-dnd-html5-backend\"], root[\"react-virtualized\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_21__, __WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_23__, __WEBPACK_EXTERNAL_MODULE_24__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _defaultHandlers = __webpack_require__(5);\n\t\n\tObject.keys(_defaultHandlers).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _defaultHandlers[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tObject.keys(_treeDataUtils).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _treeDataUtils[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _reactSortableTree = __webpack_require__(9);\n\t\n\tvar _reactSortableTree2 = _interopRequireDefault(_reactSortableTree);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _reactSortableTree2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports.getDescendantCount = getDescendantCount;\n\texports.getVisibleNodeCount = getVisibleNodeCount;\n\texports.getVisibleNodeInfoAtIndex = getVisibleNodeInfoAtIndex;\n\texports.walk = walk;\n\texports.map = map;\n\texports.toggleExpandedForAll = toggleExpandedForAll;\n\texports.changeNodeAtPath = changeNodeAtPath;\n\texports.removeNodeAtPath = removeNodeAtPath;\n\texports.getNodeAtPath = getNodeAtPath;\n\texports.addNodeUnderParent = addNodeUnderParent;\n\texports.insertNode = insertNode;\n\texports.getFlatDataFromTree = getFlatDataFromTree;\n\texports.getTreeFromFlatData = getTreeFromFlatData;\n\texports.isDescendant = isDescendant;\n\texports.getDepth = getDepth;\n\texports.find = find;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t/**\n\t * Performs a depth-first traversal over all of the node descendants,\n\t * incrementing currentIndex by 1 for each\n\t */\n\tfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n\t    var targetIndex = _ref.targetIndex;\n\t    var node = _ref.node;\n\t    var currentIndex = _ref.currentIndex;\n\t    var getNodeKey = _ref.getNodeKey;\n\t    var _ref$path = _ref.path;\n\t    var path = _ref$path === undefined ? [] : _ref$path;\n\t    var _ref$lowerSiblingCoun = _ref.lowerSiblingCounts;\n\t    var lowerSiblingCounts = _ref$lowerSiblingCoun === undefined ? [] : _ref$lowerSiblingCoun;\n\t    var _ref$ignoreCollapsed = _ref.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref$ignoreCollapsed === undefined ? true : _ref$ignoreCollapsed;\n\t    var _ref$isPseudoRoot = _ref.isPseudoRoot;\n\t    var isPseudoRoot = _ref$isPseudoRoot === undefined ? false : _ref$isPseudoRoot;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]) : [];\n\t\n\t    // Return target node when found\n\t    if (currentIndex === targetIndex) {\n\t        return {\n\t            node: node,\n\t            lowerSiblingCounts: lowerSiblingCounts,\n\t            path: selfPath\n\t        };\n\t    }\n\t\n\t    // Add one and continue for nodes with no children or hidden children\n\t    if (!node.children || ignoreCollapsed && node.expanded !== true) {\n\t        return { nextIndex: currentIndex + 1 };\n\t    }\n\t\n\t    // Iterate over each child and their descendants and return the\n\t    // target node if childIndex reaches the targetIndex\n\t    var childIndex = currentIndex + 1;\n\t    var childCount = node.children.length;\n\t    for (var i = 0; i < childCount; i++) {\n\t        var result = getNodeDataAtTreeIndexOrNextIndex({\n\t            ignoreCollapsed: ignoreCollapsed,\n\t            getNodeKey: getNodeKey,\n\t            targetIndex: targetIndex,\n\t            node: node.children[i],\n\t            currentIndex: childIndex,\n\t            lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t            path: selfPath\n\t        });\n\t\n\t        if (result.node) {\n\t            return result;\n\t        }\n\t\n\t        childIndex = result.nextIndex;\n\t    }\n\t\n\t    // If the target node is not found, return the farthest traversed index\n\t    return { nextIndex: childIndex };\n\t}\n\t\n\tfunction getDescendantCount(_ref2) {\n\t    var node = _ref2.node;\n\t    var _ref2$ignoreCollapsed = _ref2.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref2$ignoreCollapsed === undefined ? true : _ref2$ignoreCollapsed;\n\t\n\t    return getNodeDataAtTreeIndexOrNextIndex({\n\t        getNodeKey: function getNodeKey() {},\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        node: node,\n\t        currentIndex: 0,\n\t        targetIndex: -1\n\t    }).nextIndex - 1;\n\t}\n\t\n\t/**\n\t * Walk all descendants of the given node\n\t */\n\tfunction walkDescendants(_ref3) {\n\t    var callback = _ref3.callback;\n\t    var getNodeKey = _ref3.getNodeKey;\n\t    var ignoreCollapsed = _ref3.ignoreCollapsed;\n\t    var _ref3$isPseudoRoot = _ref3.isPseudoRoot;\n\t    var isPseudoRoot = _ref3$isPseudoRoot === undefined ? false : _ref3$isPseudoRoot;\n\t    var node = _ref3.node;\n\t    var currentIndex = _ref3.currentIndex;\n\t    var _ref3$path = _ref3.path;\n\t    var path = _ref3$path === undefined ? [] : _ref3$path;\n\t    var _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts;\n\t    var lowerSiblingCounts = _ref3$lowerSiblingCou === undefined ? [] : _ref3$lowerSiblingCou;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]) : [];\n\t    var selfInfo = !isPseudoRoot ? { node: node, path: selfPath, lowerSiblingCounts: lowerSiblingCounts, treeIndex: currentIndex } : null;\n\t    if (!isPseudoRoot) {\n\t        var callbackResult = callback(selfInfo);\n\t\n\t        // Cut walk short if the callback returned false\n\t        if (callbackResult === false) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    // Return self on nodes with no children or hidden children\n\t    if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return currentIndex;\n\t    }\n\t\n\t    // Get all descendants\n\t    var childIndex = currentIndex;\n\t    var childCount = node.children.length;\n\t    if (typeof node.children !== 'function') {\n\t        for (var i = 0; i < childCount; i++) {\n\t            childIndex = walkDescendants({\n\t                callback: callback,\n\t                getNodeKey: getNodeKey,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                node: node.children[i],\n\t                currentIndex: childIndex + 1,\n\t                lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t                path: selfPath\n\t            });\n\t\n\t            // Cut walk short if the callback returned false\n\t            if (childIndex === false) {\n\t                return false;\n\t            }\n\t        }\n\t    }\n\t\n\t    return childIndex;\n\t}\n\t\n\t/**\n\t * Perform a change on the given node and all its descendants\n\t */\n\tfunction mapDescendants(_ref4) {\n\t    var callback = _ref4.callback;\n\t    var getNodeKey = _ref4.getNodeKey;\n\t    var ignoreCollapsed = _ref4.ignoreCollapsed;\n\t    var _ref4$isPseudoRoot = _ref4.isPseudoRoot;\n\t    var isPseudoRoot = _ref4$isPseudoRoot === undefined ? false : _ref4$isPseudoRoot;\n\t    var node = _ref4.node;\n\t    var currentIndex = _ref4.currentIndex;\n\t    var _ref4$path = _ref4.path;\n\t    var path = _ref4$path === undefined ? [] : _ref4$path;\n\t    var _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts;\n\t    var lowerSiblingCounts = _ref4$lowerSiblingCou === undefined ? [] : _ref4$lowerSiblingCou;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]) : [];\n\t    var selfInfo = !isPseudoRoot ? { node: node, path: selfPath, lowerSiblingCounts: lowerSiblingCounts, treeIndex: currentIndex } : null;\n\t\n\t    // Return self on nodes with no children or hidden children\n\t    if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return {\n\t            treeIndex: currentIndex,\n\t            node: callback(selfInfo)\n\t        };\n\t    }\n\t\n\t    // Get all descendants\n\t    var childIndex = currentIndex;\n\t    var childCount = node.children.length;\n\t    var newChildren = node.children;\n\t    if (typeof newChildren !== 'function') {\n\t        newChildren = newChildren.map(function (child, i) {\n\t            var mapResult = mapDescendants({\n\t                callback: callback,\n\t                getNodeKey: getNodeKey,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                node: child,\n\t                currentIndex: childIndex + 1,\n\t                lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t                path: selfPath\n\t            });\n\t            childIndex = mapResult.treeIndex;\n\t\n\t            return mapResult.node;\n\t        });\n\t    }\n\t\n\t    return {\n\t        node: callback(_extends({}, selfInfo, {\n\t            node: _extends({}, node, {\n\t                children: newChildren\n\t            })\n\t        })),\n\t        treeIndex: childIndex\n\t    };\n\t}\n\t\n\t/**\n\t * Count all the visible (expanded) descendants in the tree data.\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t *\n\t * @return {number} count\n\t */\n\tfunction getVisibleNodeCount(_ref5) {\n\t    var treeData = _ref5.treeData;\n\t\n\t    var traverse = function traverse(node) {\n\t        if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n\t            return 1;\n\t        }\n\t\n\t        return 1 + node.children.reduce(function (total, currentNode) {\n\t            return total + traverse(currentNode);\n\t        }, 0);\n\t    };\n\t\n\t    return treeData.reduce(function (total, currentNode) {\n\t        return total + traverse(currentNode);\n\t    }, 0);\n\t}\n\t\n\t/**\n\t * Get the <targetIndex>th visible node in the tree data.\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!number} targetIndex - The index of the node to search for\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t *\n\t * @return {{\n\t *      node: Object,\n\t *      path: []string|[]number,\n\t *      lowerSiblingCounts: []number\n\t *  }|null} node - The node at targetIndex, or null if not found\n\t */\n\tfunction getVisibleNodeInfoAtIndex(_ref6) {\n\t    var treeData = _ref6.treeData;\n\t    var targetIndex = _ref6.index;\n\t    var getNodeKey = _ref6.getNodeKey;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return null;\n\t    }\n\t\n\t    // Call the tree traversal with a pseudo-root node\n\t    var result = getNodeDataAtTreeIndexOrNextIndex({\n\t        targetIndex: targetIndex,\n\t        getNodeKey: getNodeKey,\n\t        node: {\n\t            children: treeData,\n\t            expanded: true\n\t        },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: [],\n\t        isPseudoRoot: true\n\t    });\n\t\n\t    if (result.node) {\n\t        return result;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t * Walk descendants depth-first and call a callback on each\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {function} callback - Function to call on each node\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t */\n\tfunction walk(_ref7) {\n\t    var treeData = _ref7.treeData;\n\t    var getNodeKey = _ref7.getNodeKey;\n\t    var callback = _ref7.callback;\n\t    var _ref7$ignoreCollapsed = _ref7.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref7$ignoreCollapsed === undefined ? true : _ref7$ignoreCollapsed;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return;\n\t    }\n\t\n\t    return walkDescendants({\n\t        callback: callback,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        isPseudoRoot: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: []\n\t    });\n\t}\n\t\n\t/**\n\t * Perform a depth-first transversal of the descendants and\n\t *  make a change to every node in the tree\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {function} callback - Function to call on each node\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t */\n\tfunction map(_ref8) {\n\t    var treeData = _ref8.treeData;\n\t    var getNodeKey = _ref8.getNodeKey;\n\t    var callback = _ref8.callback;\n\t    var _ref8$ignoreCollapsed = _ref8.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref8$ignoreCollapsed === undefined ? true : _ref8$ignoreCollapsed;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return [];\n\t    }\n\t\n\t    return mapDescendants({\n\t        callback: callback,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        isPseudoRoot: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: []\n\t    }).node.children;\n\t}\n\t\n\t/**\n\t * Expand or close every node in the tree\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {?boolean} expanded - Whether the node is expanded or not\n\t */\n\tfunction toggleExpandedForAll(_ref9) {\n\t    var treeData = _ref9.treeData;\n\t    var _ref9$expanded = _ref9.expanded;\n\t    var expanded = _ref9$expanded === undefined ? true : _ref9$expanded;\n\t\n\t    return map({\n\t        treeData: treeData,\n\t        callback: function callback(_ref10) {\n\t            var node = _ref10.node;\n\t            return _extends({}, node, { expanded: expanded });\n\t        },\n\t        getNodeKey: function getNodeKey(_ref11) {\n\t            var treeIndex = _ref11.treeIndex;\n\t            return treeIndex;\n\t        },\n\t        ignoreCollapsed: false\n\t    });\n\t}\n\t\n\t/**\n\t * Replaces node at path with object, or callback-defined object\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n\t * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {Object} changedTreeData - The updated tree data\n\t */\n\tfunction changeNodeAtPath(_ref12) {\n\t    var treeData = _ref12.treeData;\n\t    var path = _ref12.path;\n\t    var newNode = _ref12.newNode;\n\t    var getNodeKey = _ref12.getNodeKey;\n\t    var _ref12$ignoreCollapse = _ref12.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref12$ignoreCollapse === undefined ? true : _ref12$ignoreCollapse;\n\t\n\t    var RESULT_MISS = 'RESULT_MISS';\n\t    var traverse = function traverse(_ref13) {\n\t        var _ref13$isPseudoRoot = _ref13.isPseudoRoot;\n\t        var isPseudoRoot = _ref13$isPseudoRoot === undefined ? false : _ref13$isPseudoRoot;\n\t        var node = _ref13.node;\n\t        var currentTreeIndex = _ref13.currentTreeIndex;\n\t        var pathIndex = _ref13.pathIndex;\n\t\n\t        if (!isPseudoRoot && getNodeKey({ node: node, treeIndex: currentTreeIndex }) !== path[pathIndex]) {\n\t            return RESULT_MISS;\n\t        }\n\t\n\t        if (pathIndex >= path.length - 1) {\n\t            // If this is the final location in the path, return its changed form\n\t            return typeof newNode === 'function' ? newNode({ node: node, treeIndex: currentTreeIndex }) : newNode;\n\t        } else if (!node.children) {\n\t            // If this node is part of the path, but has no children, return the unchanged node\n\t            throw new Error('Path referenced children of node with no children.');\n\t        }\n\t\n\t        var nextTreeIndex = currentTreeIndex + 1;\n\t        for (var i = 0; i < node.children.length; i++) {\n\t            var _result = traverse({\n\t                node: node.children[i],\n\t                currentTreeIndex: nextTreeIndex,\n\t                pathIndex: pathIndex + 1\n\t            });\n\t\n\t            // If the result went down the correct path\n\t            if (_result !== RESULT_MISS) {\n\t                if (_result) {\n\t                    // If the result was truthy (in this case, an object),\n\t                    //  pass it to the next level of recursion up\n\t                    return _extends({}, node, {\n\t                        children: [].concat(_toConsumableArray(node.children.slice(0, i)), [_result], _toConsumableArray(node.children.slice(i + 1)))\n\t                    });\n\t                }\n\t                // If the result was falsy (returned from the newNode function), then\n\t                //  delete the node from the array.\n\t                return _extends({}, node, {\n\t                    children: [].concat(_toConsumableArray(node.children.slice(0, i)), _toConsumableArray(node.children.slice(i + 1)))\n\t                });\n\t            }\n\t\n\t            nextTreeIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed: ignoreCollapsed });\n\t        }\n\t\n\t        return RESULT_MISS;\n\t    };\n\t\n\t    // Use a pseudo-root node in the beginning traversal\n\t    var result = traverse({\n\t        node: { children: treeData },\n\t        currentTreeIndex: -1,\n\t        pathIndex: -1,\n\t        isPseudoRoot: true\n\t    });\n\t\n\t    if (result === RESULT_MISS) {\n\t        throw new Error('No node found at the given path.');\n\t    }\n\t\n\t    return result.children;\n\t}\n\t\n\t/**\n\t * Removes the node at the specified path and returns the resulting treeData.\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {Object} changedTreeData - The updated tree data\n\t */\n\tfunction removeNodeAtPath(_ref14) {\n\t    var treeData = _ref14.treeData;\n\t    var path = _ref14.path;\n\t    var getNodeKey = _ref14.getNodeKey;\n\t    var _ref14$ignoreCollapse = _ref14.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref14$ignoreCollapse === undefined ? true : _ref14$ignoreCollapse;\n\t\n\t    return changeNodeAtPath({\n\t        treeData: treeData,\n\t        path: path,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        newNode: null });\n\t}\n\t\n\t/**\n\t * Gets the node at the specified path\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n\t */\n\tfunction getNodeAtPath(_ref15) {\n\t    var treeData = _ref15.treeData;\n\t    var path = _ref15.path;\n\t    var getNodeKey = _ref15.getNodeKey;\n\t    var _ref15$ignoreCollapse = _ref15.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref15$ignoreCollapse === undefined ? true : _ref15$ignoreCollapse;\n\t\n\t    var foundNodeInfo = null;\n\t\n\t    try {\n\t        changeNodeAtPath({\n\t            treeData: treeData,\n\t            path: path,\n\t            getNodeKey: getNodeKey,\n\t            ignoreCollapsed: ignoreCollapsed,\n\t            newNode: function newNode(_ref16) {\n\t                var node = _ref16.node;\n\t                var treeIndex = _ref16.treeIndex;\n\t\n\t                foundNodeInfo = { node: node, treeIndex: treeIndex };\n\t                return node;\n\t            }\n\t        });\n\t    } catch (err) {\n\t        // Ignore the error -- the null return will be explanation enough\n\t    }\n\t\n\t    return foundNodeInfo;\n\t}\n\t\n\t/**\n\t * Adds the node to the specified parent and returns the resulting treeData.\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {!Object} newNode - The node to insert\n\t * @param {number|string} parentKey - The key of the to-be parentNode of the node\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n\t *\n\t * @return {Object} result\n\t * @return {Object} result.treeData - The updated tree data\n\t * @return {number} result.treeIndex - The tree index at which the node was inserted\n\t */\n\tfunction addNodeUnderParent(_ref17) {\n\t    var treeData = _ref17.treeData;\n\t    var newNode = _ref17.newNode;\n\t    var _ref17$parentKey = _ref17.parentKey;\n\t    var parentKey = _ref17$parentKey === undefined ? null : _ref17$parentKey;\n\t    var getNodeKey = _ref17.getNodeKey;\n\t    var _ref17$ignoreCollapse = _ref17.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref17$ignoreCollapse === undefined ? true : _ref17$ignoreCollapse;\n\t    var _ref17$expandParent = _ref17.expandParent;\n\t    var expandParent = _ref17$expandParent === undefined ? false : _ref17$expandParent;\n\t\n\t    if (parentKey === null) {\n\t        return {\n\t            treeData: [].concat(_toConsumableArray(treeData || []), [newNode]),\n\t            treeIndex: (treeData || []).length\n\t        };\n\t    }\n\t\n\t    var insertedTreeIndex = null;\n\t    var hasBeenAdded = false;\n\t    var changedTreeData = map({\n\t        treeData: treeData,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        callback: function callback(_ref18) {\n\t            var node = _ref18.node;\n\t            var treeIndex = _ref18.treeIndex;\n\t            var path = _ref18.path;\n\t\n\t            var key = path ? path[path.length - 1] : null;\n\t            // Return nodes that are not the parent as-is\n\t            if (hasBeenAdded || key !== parentKey) {\n\t                return node;\n\t            }\n\t            hasBeenAdded = true;\n\t\n\t            var parentNode = _extends({}, node);\n\t\n\t            if (expandParent) {\n\t                parentNode.expanded = true;\n\t            }\n\t\n\t            // If no children exist yet, just add the single newNode\n\t            if (!parentNode.children) {\n\t                insertedTreeIndex = treeIndex + 1;\n\t                return _extends({}, parentNode, {\n\t                    children: [newNode]\n\t                });\n\t            }\n\t\n\t            if (typeof parentNode.children === 'function') {\n\t                throw new Error('Cannot add to children defined by a function');\n\t            }\n\t\n\t            var nextTreeIndex = treeIndex + 1;\n\t            for (var i = 0; i < parentNode.children.length; i++) {\n\t                nextTreeIndex += 1 + getDescendantCount({ node: parentNode.children[i], ignoreCollapsed: ignoreCollapsed });\n\t            }\n\t\n\t            insertedTreeIndex = nextTreeIndex;\n\t\n\t            return _extends({}, parentNode, {\n\t                children: [].concat(_toConsumableArray(parentNode.children), [newNode])\n\t            });\n\t        }\n\t    });\n\t\n\t    if (!hasBeenAdded) {\n\t        throw new Error('No node found with the given key.');\n\t    }\n\t\n\t    return {\n\t        treeData: changedTreeData,\n\t        treeIndex: insertedTreeIndex\n\t    };\n\t}\n\t\n\tfunction addNodeAtDepthAndIndex(_ref19) {\n\t    var targetDepth = _ref19.targetDepth;\n\t    var minimumTreeIndex = _ref19.minimumTreeIndex;\n\t    var newNode = _ref19.newNode;\n\t    var ignoreCollapsed = _ref19.ignoreCollapsed;\n\t    var expandParent = _ref19.expandParent;\n\t    var _ref19$isPseudoRoot = _ref19.isPseudoRoot;\n\t    var isPseudoRoot = _ref19$isPseudoRoot === undefined ? false : _ref19$isPseudoRoot;\n\t    var isLastChild = _ref19.isLastChild;\n\t    var node = _ref19.node;\n\t    var currentIndex = _ref19.currentIndex;\n\t    var currentDepth = _ref19.currentDepth;\n\t\n\t    if (currentDepth === targetDepth) {\n\t        return {\n\t            node: node,\n\t            nextIndex: currentIndex + 1 + getDescendantCount({ node: node, ignoreCollapsed: ignoreCollapsed })\n\t        };\n\t    }\n\t\n\t    // If the current position is the only possible place to add, add it\n\t    if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !node.children) {\n\t        if (typeof node.children === 'function') {\n\t            throw new Error('Cannot add to children defined by a function');\n\t        } else {\n\t            var extraNodeProps = expandParent ? { expanded: true } : {};\n\t            return {\n\t                node: _extends({}, node, extraNodeProps, {\n\t                    children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n\t                }),\n\t                nextIndex: currentIndex + 2,\n\t                insertedTreeIndex: currentIndex + 1\n\t            };\n\t        }\n\t    }\n\t\n\t    if (currentDepth === targetDepth - 1) {\n\t        // Skip over nodes with no children or hidden children\n\t        if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t            return { node: node, nextIndex: currentIndex + 1 };\n\t        }\n\t\n\t        var _childIndex = currentIndex + 1;\n\t        var _insertedTreeIndex = null;\n\t        var insertIndex = null;\n\t        for (var i = 0; i < node.children.length; i++) {\n\t            if (_childIndex >= minimumTreeIndex) {\n\t                _insertedTreeIndex = _childIndex;\n\t                insertIndex = i;\n\t                break;\n\t            }\n\t\n\t            _childIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed: ignoreCollapsed });\n\t        }\n\t\n\t        if (insertIndex === null) {\n\t            if (_childIndex < minimumTreeIndex && !isLastChild) {\n\t                return { node: node, nextIndex: _childIndex };\n\t            }\n\t\n\t            _insertedTreeIndex = _childIndex;\n\t            insertIndex = node.children.length;\n\t        }\n\t\n\t        return {\n\t            node: _extends({}, node, {\n\t                children: [].concat(_toConsumableArray(node.children.slice(0, insertIndex)), [newNode], _toConsumableArray(node.children.slice(insertIndex)))\n\t            }),\n\t            nextIndex: _childIndex,\n\t            insertedTreeIndex: _insertedTreeIndex\n\t        };\n\t    }\n\t\n\t    // Skip over nodes with no children or hidden children\n\t    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return { node: node, nextIndex: currentIndex + 1 };\n\t    }\n\t\n\t    // Get all descendants\n\t    var insertedTreeIndex = null;\n\t    var childIndex = currentIndex + 1;\n\t    var newChildren = node.children;\n\t    if (typeof newChildren !== 'function') {\n\t        newChildren = newChildren.map(function (child, i) {\n\t            if (insertedTreeIndex !== null) {\n\t                return child;\n\t            }\n\t\n\t            var mapResult = addNodeAtDepthAndIndex({\n\t                targetDepth: targetDepth,\n\t                minimumTreeIndex: minimumTreeIndex,\n\t                newNode: newNode,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                expandParent: expandParent,\n\t                isLastChild: isLastChild && i === newChildren.length - 1,\n\t                node: child,\n\t                currentIndex: childIndex,\n\t                currentDepth: currentDepth + 1\n\t            });\n\t\n\t            if ('insertedTreeIndex' in mapResult) {\n\t                insertedTreeIndex = mapResult.insertedTreeIndex;\n\t            }\n\t\n\t            childIndex = mapResult.nextIndex;\n\t\n\t            return mapResult.node;\n\t        });\n\t    }\n\t\n\t    var result = {\n\t        node: _extends({}, node, { children: newChildren }),\n\t        nextIndex: childIndex\n\t    };\n\t\n\t    if (insertedTreeIndex !== null) {\n\t        result.insertedTreeIndex = insertedTreeIndex;\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t/**\n\t * Insert a node into the tree at the given depth, after the minimum index\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!number} depth - The depth to insert the node at\n\t * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n\t * @param {!Object} newNode - The node to insert into the tree\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n\t */\n\tfunction insertNode(_ref20) {\n\t    var treeData = _ref20.treeData;\n\t    var targetDepth = _ref20.depth;\n\t    var minimumTreeIndex = _ref20.minimumTreeIndex;\n\t    var newNode = _ref20.newNode;\n\t    var _ref20$ignoreCollapse = _ref20.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref20$ignoreCollapse === undefined ? true : _ref20$ignoreCollapse;\n\t    var _ref20$expandParent = _ref20.expandParent;\n\t    var expandParent = _ref20$expandParent === undefined ? false : _ref20$expandParent;\n\t\n\t    if (!treeData && targetDepth === 0) {\n\t        return {\n\t            treeData: [newNode],\n\t            treeIndex: 0\n\t        };\n\t    }\n\t\n\t    var insertResult = addNodeAtDepthAndIndex({\n\t        targetDepth: targetDepth,\n\t        minimumTreeIndex: minimumTreeIndex,\n\t        newNode: newNode,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        expandParent: expandParent,\n\t        isPseudoRoot: true,\n\t        isLastChild: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        currentDepth: -1\n\t    });\n\t\n\t    if (!('insertedTreeIndex' in insertResult)) {\n\t        throw new Error('No suitable position found to insert.');\n\t    }\n\t\n\t    return {\n\t        treeData: insertResult.node.children,\n\t        treeIndex: insertResult.insertedTreeIndex\n\t    };\n\t}\n\t\n\t/**\n\t * Get tree data flattened.\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {{\n\t *      node: Object,\n\t *      path: []string|[]number,\n\t *      lowerSiblingCounts: []number\n\t *  }}[] nodes - The node array\n\t */\n\tfunction getFlatDataFromTree(_ref21) {\n\t    var treeData = _ref21.treeData;\n\t    var getNodeKey = _ref21.getNodeKey;\n\t    var _ref21$ignoreCollapse = _ref21.ignoreCollapsed;\n\t    var ignoreCollapsed = _ref21$ignoreCollapse === undefined ? true : _ref21$ignoreCollapse;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return [];\n\t    }\n\t\n\t    var flattened = [];\n\t    walk({\n\t        treeData: treeData,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        callback: function callback(_ref22) {\n\t            var node = _ref22.node;\n\t            var lowerSiblingCounts = _ref22.lowerSiblingCounts;\n\t            var path = _ref22.path;\n\t            var treeIndex = _ref22.treeIndex;\n\t\n\t            flattened.push({ node: node, lowerSiblingCounts: lowerSiblingCounts, path: path, treeIndex: treeIndex });\n\t        }\n\t    });\n\t\n\t    return flattened;\n\t}\n\t\n\t/**\n\t * Generate a tree structure from flat data.\n\t *\n\t * @param {!Object[]} flatData\n\t * @param {!function} getKey - Function to get the key from the nodeData\n\t * @param {!function} getParentKey - Function to get the parent key from the nodeData\n\t *\n\t * @return {Object[]} treeData - The flat data represented as a tree\n\t */\n\tfunction getTreeFromFlatData(_ref23) {\n\t    var flatData = _ref23.flatData;\n\t    var getKey = _ref23.getKey;\n\t    var getParentKey = _ref23.getParentKey;\n\t    var rootKey = _ref23.rootKey;\n\t\n\t    if (!flatData) {\n\t        return [];\n\t    }\n\t\n\t    var childrenToParents = {};\n\t    flatData.forEach(function (child) {\n\t        var parentKey = getParentKey(child);\n\t\n\t        if (parentKey in childrenToParents) {\n\t            childrenToParents[parentKey].push(child);\n\t        } else {\n\t            childrenToParents[parentKey] = [child];\n\t        }\n\t    });\n\t\n\t    if (!(rootKey in childrenToParents)) {\n\t        return [];\n\t    }\n\t\n\t    var trav = function trav(parent) {\n\t        var parentKey = getKey(parent);\n\t        if (parentKey in childrenToParents) {\n\t            return _extends({}, parent, {\n\t                children: childrenToParents[parentKey].map(function (child) {\n\t                    return trav(child);\n\t                })\n\t            });\n\t        }\n\t\n\t        return _extends({}, parent);\n\t    };\n\t\n\t    return childrenToParents[rootKey].map(function (child) {\n\t        return trav(child);\n\t    });\n\t}\n\t\n\t/**\n\t * Check if a node is a descendant of another node.\n\t *\n\t * @param {!Object} older - Potential ancestor of younger node\n\t * @param {!Object} younger - Potential descendant of older node\n\t *\n\t * @return {boolean}\n\t */\n\tfunction isDescendant(older, younger) {\n\t    return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n\t        return child === younger || isDescendant(child, younger);\n\t    });\n\t}\n\t\n\t/**\n\t * Get the maximum depth of the children (the depth of the root node is 0).\n\t *\n\t * @param {!Object} node - Node in the tree\n\t * @param {?number} depth - The current depth\n\t *\n\t * @return {boolean}\n\t */\n\tfunction getDepth(node) {\n\t    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t    if (!node.children) {\n\t        return depth;\n\t    }\n\t\n\t    if (typeof node.children === 'function') {\n\t        return depth + 1;\n\t    }\n\t\n\t    return node.children.reduce(function (deepest, child) {\n\t        return Math.max(deepest, getDepth(child, depth + 1));\n\t    }, depth);\n\t}\n\t\n\t/**\n\t * Find nodes matching a search query in the tree,\n\t *\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n\t * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n\t * @param {?number} searchFocusOffset - The offset of the match to focus on\n\t *                                      (e.g., 0 focuses on the first match, 1 on the second)\n\t * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n\t * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n\t *\n\t * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n\t * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n\t *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n\t *                               it will be the same as the original tree data.\n\t */\n\tfunction find(_ref24) {\n\t    var getNodeKey = _ref24.getNodeKey;\n\t    var treeData = _ref24.treeData;\n\t    var searchQuery = _ref24.searchQuery;\n\t    var searchMethod = _ref24.searchMethod;\n\t    var searchFocusOffset = _ref24.searchFocusOffset;\n\t    var _ref24$expandAllMatch = _ref24.expandAllMatchPaths;\n\t    var expandAllMatchPaths = _ref24$expandAllMatch === undefined ? false : _ref24$expandAllMatch;\n\t    var _ref24$expandFocusMat = _ref24.expandFocusMatchPaths;\n\t    var expandFocusMatchPaths = _ref24$expandFocusMat === undefined ? true : _ref24$expandFocusMat;\n\t\n\t    var matchCount = 0;\n\t    var trav = function trav(_ref25) {\n\t        var _ref25$isPseudoRoot = _ref25.isPseudoRoot;\n\t        var isPseudoRoot = _ref25$isPseudoRoot === undefined ? false : _ref25$isPseudoRoot;\n\t        var node = _ref25.node;\n\t        var currentIndex = _ref25.currentIndex;\n\t        var _ref25$path = _ref25.path;\n\t        var path = _ref25$path === undefined ? [] : _ref25$path;\n\t\n\t        var matches = [];\n\t        var isSelfMatch = false;\n\t        var hasFocusMatch = false;\n\t        // The pseudo-root is not considered in the path\n\t        var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]);\n\t        var extraInfo = isPseudoRoot ? null : {\n\t            path: selfPath,\n\t            treeIndex: currentIndex\n\t        };\n\t\n\t        // Nodes with with children that aren't lazy\n\t        var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0;\n\t\n\t        // Examine the current node to see if it is a match\n\t        if (!isPseudoRoot && searchMethod(_extends({}, extraInfo, { node: node, searchQuery: searchQuery }))) {\n\t            if (matchCount === searchFocusOffset) {\n\t                hasFocusMatch = true;\n\t            }\n\t\n\t            // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n\t            //  is reached\n\t            matchCount++;\n\t\n\t            // We cannot add this node to the matches right away, as it may be changed\n\t            //  during the search of the descendants. The entire node is used in\n\t            //  comparisons between nodes inside the `matches` and `treeData` results\n\t            //  of this method (`find`)\n\t            isSelfMatch = true;\n\t        }\n\t\n\t        var childIndex = currentIndex;\n\t        var newNode = _extends({}, node);\n\t        if (hasChildren) {\n\t            // Get all descendants\n\t            newNode.children = newNode.children.map(function (child) {\n\t                var mapResult = trav({\n\t                    node: child,\n\t                    currentIndex: childIndex + 1,\n\t                    path: selfPath\n\t                });\n\t\n\t                // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n\t                // if the child is expanded.\n\t                //\n\t                // The child could have been expanded from the start,\n\t                // or expanded due to a matching node being found in its descendants\n\t                if (mapResult.node.expanded) {\n\t                    childIndex = mapResult.treeIndex;\n\t                } else {\n\t                    childIndex += 1;\n\t                }\n\t\n\t                if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n\t                    matches = [].concat(_toConsumableArray(matches), _toConsumableArray(mapResult.matches));\n\t                    if (mapResult.hasFocusMatch) {\n\t                        hasFocusMatch = true;\n\t                    }\n\t\n\t                    // Expand the current node if it has descendants matching the search\n\t                    // and the settings are set to do so.\n\t                    if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n\t                        newNode.expanded = true;\n\t                    }\n\t                }\n\t\n\t                return mapResult.node;\n\t            });\n\t        }\n\t\n\t        // Cannot assign a treeIndex to hidden nodes\n\t        if (!isPseudoRoot && !newNode.expanded) {\n\t            matches = matches.map(function (match) {\n\t                return _extends({}, match, {\n\t                    treeIndex: null\n\t                });\n\t            });\n\t        }\n\t\n\t        // Add this node to the matches if it fits the search criteria.\n\t        // This is performed at the last minute so newNode can be sent in its final form.\n\t        if (isSelfMatch) {\n\t            matches = [_extends({}, extraInfo, { node: newNode })].concat(_toConsumableArray(matches));\n\t        }\n\t\n\t        return {\n\t            node: matches.length > 0 ? newNode : node,\n\t            matches: matches,\n\t            hasFocusMatch: hasFocusMatch,\n\t            treeIndex: childIndex\n\t        };\n\t    };\n\t\n\t    var result = trav({\n\t        node: { children: treeData },\n\t        isPseudoRoot: true,\n\t        currentIndex: -1\n\t    });\n\t\n\t    return {\n\t        matches: result.matches,\n\t        treeData: result.node.children\n\t    };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.defaultGetNodeKey = defaultGetNodeKey;\n\texports.defaultSearchMethod = defaultSearchMethod;\n\tfunction defaultGetNodeKey(_ref) {\n\t    var _node = _ref.node;\n\t    var treeIndex = _ref.treeIndex;\n\t\n\t    return treeIndex;\n\t}\n\t\n\t// Cheap hack to get the text of a react object\n\tfunction getReactElementText(parent) {\n\t    if (typeof parent === 'string') {\n\t        return parent;\n\t    }\n\t\n\t    if ((typeof parent === 'undefined' ? 'undefined' : _typeof(parent)) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {\n\t        return '';\n\t    }\n\t\n\t    if (typeof parent.props.children === 'string') {\n\t        return parent.props.children;\n\t    }\n\t\n\t    return parent.props.children.map(function (child) {\n\t        return getReactElementText(child);\n\t    }).join('');\n\t}\n\t\n\t// Search for a query string inside a node property\n\tfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n\t    if (typeof node[key] === 'function') {\n\t        return String(node[key]({ node: node, path: path, treeIndex: treeIndex })).indexOf(searchQuery) > -1;\n\t    } else if (_typeof(node[key]) === 'object') {\n\t        return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n\t    }\n\t\n\t    return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n\t}\n\t\n\tfunction defaultSearchMethod(_ref2) {\n\t    var node = _ref2.node;\n\t    var path = _ref2.path;\n\t    var treeIndex = _ref2.treeIndex;\n\t    var searchQuery = _ref2.searchQuery;\n\t\n\t    return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.dndWrapSource = dndWrapSource;\n\texports.dndWrapTarget = dndWrapTarget;\n\texports.dndWrapRoot = dndWrapRoot;\n\t\n\tvar _reactDnd = __webpack_require__(22);\n\t\n\tvar _reactDndHtml5Backend = __webpack_require__(23);\n\t\n\tvar _reactDndHtml5Backend2 = _interopRequireDefault(_reactDndHtml5Backend);\n\t\n\tvar _itemTypes = __webpack_require__(7);\n\t\n\tvar _itemTypes2 = _interopRequireDefault(_itemTypes);\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar nodeDragSource = {\n\t    beginDrag: function beginDrag(props) {\n\t        props.startDrag(props);\n\t\n\t        return {\n\t            node: props.node,\n\t            path: props.path\n\t        };\n\t    },\n\t    endDrag: function endDrag(props, monitor) {\n\t        props.endDrag(monitor.getDropResult());\n\t    },\n\t    isDragging: function isDragging(props, monitor) {\n\t        var dropTargetNode = monitor.getItem().node;\n\t        var draggedNode = props.node;\n\t\n\t        return draggedNode === dropTargetNode;\n\t    }\n\t};\n\t\n\tfunction getTargetDepth(dropTargetProps, monitor) {\n\t    var dropTargetDepth = 0;\n\t    var draggedItem = monitor.getItem();\n\t    var rowAbove = dropTargetProps.getPrevRow();\n\t    if (rowAbove) {\n\t        // Limit the length of the path to the deepest possible\n\t        dropTargetDepth = Math.min(rowAbove.path.length, dropTargetProps.path.length);\n\t    }\n\t\n\t    var blocksOffset = Math.round(monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);\n\t\n\t    var targetDepth = Math.min(dropTargetDepth, Math.max(0, draggedItem.path.length + blocksOffset - 1));\n\t\n\t    // If a maxDepth is defined, constrain the target depth\n\t    if (typeof dropTargetProps.maxDepth !== 'undefined' && dropTargetProps.maxDepth !== null) {\n\t        var draggedNode = monitor.getItem().node;\n\t        var draggedChildDepth = (0, _treeDataUtils.getDepth)(draggedNode);\n\t\n\t        targetDepth = Math.min(targetDepth, dropTargetProps.maxDepth - draggedChildDepth - 1);\n\t    }\n\t\n\t    return targetDepth;\n\t}\n\t\n\tfunction canDrop(dropTargetProps, monitor) {\n\t    var isHover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t    var abovePath = [];\n\t    var aboveNode = {};\n\t    var rowAbove = dropTargetProps.getPrevRow();\n\t    if (rowAbove) {\n\t        abovePath = rowAbove.path;\n\t        aboveNode = rowAbove.node;\n\t    }\n\t\n\t    var targetDepth = getTargetDepth(dropTargetProps, monitor);\n\t    var draggedNode = monitor.getItem().node;\n\t    return (\n\t    // Either we're not adding to the children of the row above...\n\t    targetDepth < abovePath.length ||\n\t    // ...or we guarantee it's not a function we're trying to add to\n\t    typeof aboveNode.children !== 'function') && (\n\t    // Ignore when hovered above the identical node...\n\t    !(dropTargetProps.node === draggedNode && isHover === true) ||\n\t    // ...unless it's at a different level than the current one\n\t    targetDepth !== dropTargetProps.path.length - 1);\n\t}\n\t\n\tvar nodeDropTarget = {\n\t    drop: function drop(dropTargetProps, monitor) {\n\t        return {\n\t            node: monitor.getItem().node,\n\t            path: monitor.getItem().path,\n\t            minimumTreeIndex: dropTargetProps.treeIndex,\n\t            depth: getTargetDepth(dropTargetProps, monitor)\n\t        };\n\t    },\n\t    hover: function hover(dropTargetProps, monitor) {\n\t        if (!canDrop(dropTargetProps, monitor, true)) {\n\t            return;\n\t        }\n\t\n\t        dropTargetProps.dragHover({\n\t            node: monitor.getItem().node,\n\t            path: monitor.getItem().path,\n\t            minimumTreeIndex: dropTargetProps.listIndex,\n\t            depth: getTargetDepth(dropTargetProps, monitor)\n\t        });\n\t    },\n\t\n\t\n\t    canDrop: canDrop\n\t};\n\t\n\tvar scrollDropTarget = {\n\t    hover: function hover(props, monitor, component) {\n\t        var _this = this;\n\t\n\t        var cancelAnimationFrame = window.cancelAnimationFrame || function (timeout) {\n\t            return clearTimeout(timeout);\n\t        };\n\t        var requestAnimationFrame = window.requestAnimationFrame || function (func) {\n\t            return setTimeout(func, 1000 / 60);\n\t        };\n\t\n\t        // If already scrolling, stop the previous scroll loop\n\t        if (this.lastScroll) {\n\t            cancelAnimationFrame(this.lastScroll);\n\t            this.lastScroll = null;\n\t            clearTimeout(this.removeTimeout);\n\t        }\n\t\n\t        var slideRegionSize = component.props.slideRegionSize;\n\t\n\t        var _monitor$getClientOff = monitor.getClientOffset();\n\t\n\t        var dragXOffset = _monitor$getClientOff.x;\n\t        var dragYOffset = _monitor$getClientOff.y;\n\t\n\t        var _component$containerR = component.containerRef.getBoundingClientRect();\n\t\n\t        var containerTop = _component$containerR.top;\n\t        var containerBottom = _component$containerR.bottom;\n\t        var containerLeft = _component$containerR.left;\n\t        var containerRight = _component$containerR.right;\n\t\n\t        var yScrollDirection = 0;\n\t        var yScrollMagnitude = 0;\n\t        var fromTop = dragYOffset - slideRegionSize - Math.max(containerTop, 0);\n\t        if (fromTop <= 0) {\n\t            // Move up\n\t            yScrollDirection = -1;\n\t            yScrollMagnitude = Math.sqrt(-1 * fromTop);\n\t        } else {\n\t            var fromBottom = dragYOffset + slideRegionSize - Math.min(containerBottom, window.innerHeight);\n\t            if (fromBottom >= 0) {\n\t                // Move down\n\t                yScrollDirection = 1;\n\t                yScrollMagnitude = Math.sqrt(fromBottom);\n\t            }\n\t        }\n\t\n\t        var xScrollDirection = 0;\n\t        var xScrollMagnitude = 0;\n\t        var fromLeft = dragXOffset - slideRegionSize - Math.max(containerLeft, 0);\n\t        if (fromLeft <= 0) {\n\t            // Move up\n\t            xScrollDirection = -1;\n\t            xScrollMagnitude = Math.ceil(Math.sqrt(-1 * fromLeft));\n\t        } else {\n\t            var fromRight = dragXOffset + slideRegionSize - Math.min(containerRight, window.innerWidth);\n\t            if (fromRight >= 0) {\n\t                // Move down\n\t                xScrollDirection = 1;\n\t                xScrollMagnitude = Math.ceil(Math.sqrt(fromRight));\n\t            }\n\t        }\n\t\n\t        // Don't do anything if there is no scroll operation\n\t        if (xScrollDirection === 0 && yScrollDirection === 0) {\n\t            return;\n\t        }\n\t\n\t        // Indefinitely scrolls the container at a constant rate\n\t        var doScroll = function doScroll() {\n\t            component.scrollBy(xScrollDirection * xScrollMagnitude, yScrollDirection * yScrollMagnitude);\n\t            _this.lastScroll = requestAnimationFrame(doScroll);\n\t        };\n\t\n\t        // Stop the scroll loop after a period of inactivity\n\t        this.removeTimeout = setTimeout(function () {\n\t            cancelAnimationFrame(_this.lastScroll);\n\t            _this.lastScroll = null;\n\t        }, 20);\n\t\n\t        // Start the scroll loop\n\t        this.lastScroll = requestAnimationFrame(doScroll);\n\t    },\n\t    canDrop: function canDrop() {\n\t        return false;\n\t    }\n\t};\n\t\n\tfunction nodeDragSourcePropInjection(connect, monitor) {\n\t    return {\n\t        connectDragSource: connect.dragSource(),\n\t        connectDragPreview: connect.dragPreview(),\n\t        isDragging: monitor.isDragging()\n\t    };\n\t}\n\t\n\tfunction nodeDropTargetPropInjection(connect, monitor) {\n\t    var dragged = monitor.getItem();\n\t    return {\n\t        connectDropTarget: connect.dropTarget(),\n\t        isOver: monitor.isOver(),\n\t        canDrop: monitor.canDrop(),\n\t        draggedNode: dragged ? dragged.node : null\n\t    };\n\t}\n\t\n\tfunction scrollDropTargetPropInjection(connect) {\n\t    return {\n\t        _connectDropTarget: connect.dropTarget()\n\t    };\n\t}\n\t\n\tfunction dndWrapSource(el) {\n\t    return (0, _reactDnd.DragSource)(_itemTypes2.default.HANDLE, nodeDragSource, nodeDragSourcePropInjection)(el);\n\t}\n\t\n\tfunction dndWrapTarget(el) {\n\t    return (0, _reactDnd.DropTarget)(_itemTypes2.default.HANDLE, nodeDropTarget, nodeDropTargetPropInjection)(el);\n\t}\n\t\n\tfunction dndWrapRoot(el) {\n\t    return (0, _reactDnd.DragDropContext)(_reactDndHtml5Backend2.default)((0, _reactDnd.DropTarget)(_itemTypes2.default.HANDLE, scrollDropTarget, scrollDropTargetPropInjection)(el));\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    HANDLE: 'HANDLE'\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _react = __webpack_require__(4);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _browserUtils = __webpack_require__(11);\n\t\n\tvar _nodeRendererDefault = __webpack_require__(18);\n\t\n\tvar _nodeRendererDefault2 = _interopRequireDefault(_nodeRendererDefault);\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar styles = _nodeRendererDefault2.default;\n\t// Add extra classes in browsers that don't support flex\n\tif (_browserUtils.getIEVersion < 10) {\n\t    styles = _extends({}, _nodeRendererDefault2.default, {\n\t        row: styles.row + ' ' + styles.row_NoFlex,\n\t        rowContents: styles.rowContents + ' ' + styles.rowContents_NoFlex,\n\t        rowLabel: styles.rowLabel + ' ' + styles.rowLabel_NoFlex,\n\t        rowToolbar: styles.rowToolbar + ' ' + styles.rowToolbar_NoFlex\n\t    });\n\t}\n\t\n\tvar NodeRendererDefault = function NodeRendererDefault(_ref) {\n\t    var scaffoldBlockPxWidth = _ref.scaffoldBlockPxWidth;\n\t    var toggleChildrenVisibility = _ref.toggleChildrenVisibility;\n\t    var connectDragPreview = _ref.connectDragPreview;\n\t    var connectDragSource = _ref.connectDragSource;\n\t    var isDragging = _ref.isDragging;\n\t    var isOver = _ref.isOver;\n\t    var canDrop = _ref.canDrop;\n\t    var node = _ref.node;\n\t    var draggedNode = _ref.draggedNode;\n\t    var path = _ref.path;\n\t    var treeIndex = _ref.treeIndex;\n\t    var isSearchMatch = _ref.isSearchMatch;\n\t    var isSearchFocus = _ref.isSearchFocus;\n\t    var buttons = _ref.buttons;\n\t    var className = _ref.className;\n\t    var _ref$style = _ref.style;\n\t    var style = _ref$style === undefined ? {} : _ref$style;\n\t\n\t    var handle = void 0;\n\t    if (typeof node.children === 'function' && node.expanded) {\n\t        // Show a loading symbol on the handle when the children are expanded\n\t        //  and yet still defined by a function (a callback to fetch the children)\n\t        handle = _react2.default.createElement(\n\t            'div',\n\t            { className: styles.loadingHandle },\n\t            _react2.default.createElement(\n\t                'div',\n\t                { className: styles.loadingCircle },\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                _react2.default.createElement('div', { className: styles.loadingCirclePoint })\n\t            )\n\t        );\n\t    } else {\n\t        // Show the handle used to initiate a drag-and-drop\n\t        handle = connectDragSource(_react2.default.createElement('div', { className: styles.moveHandle }), { dropEffect: 'copy' });\n\t    }\n\t\n\t    var isDraggedDescendant = draggedNode && (0, _treeDataUtils.isDescendant)(draggedNode, node);\n\t\n\t    return _react2.default.createElement(\n\t        'div',\n\t        { style: { height: '100%' } },\n\t        toggleChildrenVisibility && node.children && node.children.length > 0 && _react2.default.createElement(\n\t            'div',\n\t            null,\n\t            _react2.default.createElement('div', {\n\t                className: node.expanded ? styles.collapseButton : styles.expandButton,\n\t                style: { left: -0.5 * scaffoldBlockPxWidth },\n\t                onClick: function onClick() {\n\t                    return toggleChildrenVisibility({ node: node, path: path, treeIndex: treeIndex });\n\t                }\n\t            }),\n\t            node.expanded && !isDragging && _react2.default.createElement('div', {\n\t                style: { width: scaffoldBlockPxWidth },\n\t                className: styles.lineChildren\n\t            })\n\t        ),\n\t        _react2.default.createElement(\n\t            'div',\n\t            { className: styles.rowWrapper },\n\t            connectDragPreview(_react2.default.createElement(\n\t                'div',\n\t                {\n\t                    className: styles.row + (isDragging && isOver ? ' ' + styles.rowLandingPad : '') + (isDragging && !isOver && canDrop ? ' ' + styles.rowCancelPad : '') + (isSearchMatch ? ' ' + styles.rowSearchMatch : '') + (isSearchFocus ? ' ' + styles.rowSearchFocus : '') + (className ? ' ' + className : ''),\n\t                    style: _extends({\n\t                        opacity: isDraggedDescendant ? 0.5 : 1\n\t                    }, style)\n\t                },\n\t                handle,\n\t                _react2.default.createElement(\n\t                    'div',\n\t                    { className: styles.rowContents },\n\t                    _react2.default.createElement(\n\t                        'div',\n\t                        { className: styles.rowLabel },\n\t                        _react2.default.createElement(\n\t                            'span',\n\t                            {\n\t                                className: styles.rowTitle + (node.subtitle ? ' ' + styles.rowTitleWithSubtitle : '')\n\t                            },\n\t                            typeof node.title === 'function' ? node.title({ node: node, path: path, treeIndex: treeIndex }) : node.title\n\t                        ),\n\t                        node.subtitle && _react2.default.createElement(\n\t                            'span',\n\t                            { className: styles.rowSubtitle },\n\t                            typeof node.subtitle === 'function' ? node.subtitle({ node: node, path: path, treeIndex: treeIndex }) : node.subtitle\n\t                        )\n\t                    ),\n\t                    _react2.default.createElement(\n\t                        'div',\n\t                        { className: styles.rowToolbar },\n\t                        buttons && buttons.map(function (btn, index) {\n\t                            return _react2.default.createElement(\n\t                                'div',\n\t                                { key: index, className: styles.toolbarButton },\n\t                                btn\n\t                            );\n\t                        })\n\t                    )\n\t                )\n\t            ))\n\t        )\n\t    );\n\t};\n\t\n\tNodeRendererDefault.propTypes = {\n\t    node: _react.PropTypes.object.isRequired,\n\t    path: _react.PropTypes.arrayOf(_react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number])).isRequired,\n\t    treeIndex: _react.PropTypes.number.isRequired,\n\t    isSearchMatch: _react.PropTypes.bool,\n\t    isSearchFocus: _react.PropTypes.bool,\n\t\n\t    scaffoldBlockPxWidth: _react.PropTypes.number.isRequired,\n\t    toggleChildrenVisibility: _react.PropTypes.func,\n\t    buttons: _react.PropTypes.arrayOf(_react.PropTypes.node),\n\t    className: _react.PropTypes.string,\n\t    style: _react.PropTypes.object,\n\t\n\t    // Drag and drop API functions\n\t    // Drag source\n\t    connectDragPreview: _react.PropTypes.func.isRequired,\n\t    connectDragSource: _react.PropTypes.func.isRequired,\n\t    isDragging: _react.PropTypes.bool.isRequired,\n\t    draggedNode: _react.PropTypes.object,\n\t    // Drop target\n\t    isOver: _react.PropTypes.bool.isRequired,\n\t    canDrop: _react.PropTypes.bool.isRequired\n\t};\n\t\n\texports.default = NodeRendererDefault;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(4);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactVirtualized = __webpack_require__(24);\n\t\n\tvar _lodash = __webpack_require__(21);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\t__webpack_require__(17);\n\t\n\tvar _treeNode = __webpack_require__(10);\n\t\n\tvar _treeNode2 = _interopRequireDefault(_treeNode);\n\t\n\tvar _nodeRendererDefault = __webpack_require__(8);\n\t\n\tvar _nodeRendererDefault2 = _interopRequireDefault(_nodeRendererDefault);\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tvar _genericUtils = __webpack_require__(12);\n\t\n\tvar _defaultHandlers = __webpack_require__(5);\n\t\n\tvar _dragAndDropUtils = __webpack_require__(6);\n\t\n\tvar _reactSortableTree = __webpack_require__(19);\n\t\n\tvar _reactSortableTree2 = _interopRequireDefault(_reactSortableTree);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*!\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * react-sortable-tree\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Chris Fritz All rights reserved.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license Open source under the MIT License\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar ReactSortableTree = function (_Component) {\n\t    _inherits(ReactSortableTree, _Component);\n\t\n\t    function ReactSortableTree(props) {\n\t        _classCallCheck(this, ReactSortableTree);\n\t\n\t        var _this = _possibleConstructorReturn(this, (ReactSortableTree.__proto__ || Object.getPrototypeOf(ReactSortableTree)).call(this, props));\n\t\n\t        _this.nodeContentRenderer = (0, _dragAndDropUtils.dndWrapSource)(props.nodeContentRenderer);\n\t\n\t        _this.state = {\n\t            draggingTreeData: null,\n\t            swapFrom: null,\n\t            swapLength: null,\n\t            swapDepth: null,\n\t            rows: _this.getRows(props.treeData),\n\t            searchMatches: [],\n\t            searchFocusTreeIndex: null,\n\t            scrollToPixel: null\n\t        };\n\t\n\t        _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_this);\n\t        _this.moveNode = _this.moveNode.bind(_this);\n\t        _this.startDrag = _this.startDrag.bind(_this);\n\t        _this.dragHover = _this.dragHover.bind(_this);\n\t        _this.endDrag = _this.endDrag.bind(_this);\n\t        return _this;\n\t    }\n\t\n\t    _createClass(ReactSortableTree, [{\n\t        key: 'componentWillMount',\n\t        value: function componentWillMount() {\n\t            this.loadLazyChildren();\n\t            this.search(this.props, false, false);\n\t            this.ignoreOneTreeUpdate = false;\n\t        }\n\t    }, {\n\t        key: 'toggleChildrenVisibility',\n\t        value: function toggleChildrenVisibility(_ref) {\n\t            var targetNode = _ref.node;\n\t            var path = _ref.path;\n\t            var _treeIndex = _ref.treeIndex;\n\t\n\t            var treeData = (0, _treeDataUtils.changeNodeAtPath)({\n\t                treeData: this.props.treeData,\n\t                path: path,\n\t                newNode: function newNode(_ref2) {\n\t                    var node = _ref2.node;\n\t                    return _extends({}, node, { expanded: !node.expanded });\n\t                },\n\t                getNodeKey: this.props.getNodeKey\n\t            });\n\t\n\t            this.props.onChange(treeData);\n\t\n\t            if (this.props.onVisibilityToggle) {\n\t                this.props.onVisibilityToggle({\n\t                    treeData: treeData,\n\t                    node: targetNode,\n\t                    expanded: !targetNode.expanded\n\t                });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'moveNode',\n\t        value: function moveNode(_ref3) {\n\t            var node = _ref3.node;\n\t            var depth = _ref3.depth;\n\t            var minimumTreeIndex = _ref3.minimumTreeIndex;\n\t\n\t            var treeData = (0, _treeDataUtils.insertNode)({\n\t                treeData: this.state.draggingTreeData,\n\t                newNode: node,\n\t                depth: depth,\n\t                minimumTreeIndex: minimumTreeIndex,\n\t                expandParent: true\n\t            }).treeData;\n\t\n\t            this.props.onChange(treeData);\n\t\n\t            if (this.props.onMoveNode) {\n\t                this.props.onMoveNode({ treeData: treeData, node: node });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'componentWillReceiveProps',\n\t        value: function componentWillReceiveProps(nextProps) {\n\t            this.setState({ searchFocusTreeIndex: null });\n\t            if (this.props.treeData !== nextProps.treeData) {\n\t                // Ignore updates caused by search, in order to avoid infinite looping\n\t                if (this.ignoreOneTreeUpdate) {\n\t                    this.ignoreOneTreeUpdate = false;\n\t                } else {\n\t                    this.loadLazyChildren(nextProps);\n\t                    // Load any children defined by a function\n\t                    this.search(nextProps, false, false);\n\t                }\n\t\n\t                // Calculate the rows to be shown from the new tree data\n\t                this.setState({\n\t                    draggingTreeData: null,\n\t                    swapFrom: null,\n\t                    swapLength: null,\n\t                    swapDepth: null,\n\t                    rows: this.getRows(nextProps.treeData)\n\t                });\n\t            } else if (!(0, _lodash2.default)(this.props.searchQuery, nextProps.searchQuery)) {\n\t                this.search(nextProps);\n\t            } else if (this.props.searchFocusOffset !== nextProps.searchFocusOffset) {\n\t                this.search(nextProps, true, true, true);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getRows',\n\t        value: function getRows(treeData) {\n\t            return (0, _treeDataUtils.getFlatDataFromTree)({\n\t                ignoreCollapsed: true,\n\t                getNodeKey: this.props.getNodeKey,\n\t                treeData: treeData\n\t            });\n\t        }\n\t    }, {\n\t        key: 'search',\n\t        value: function search() {\n\t            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\t            var seekIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t            var expand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t            var singleSearch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t            var treeData = props.treeData;\n\t            var onChange = props.onChange;\n\t            var searchFinishCallback = props.searchFinishCallback;\n\t            var searchQuery = props.searchQuery;\n\t            var searchMethod = props.searchMethod;\n\t            var searchFocusOffset = props.searchFocusOffset;\n\t\n\t            // Skip search if no conditions are specified\n\t\n\t            if ((searchQuery === null || typeof searchQuery === 'undefined' || String(searchQuery) === '') && !searchMethod) {\n\t                this.setState({\n\t                    searchMatches: []\n\t                });\n\t\n\t                if (searchFinishCallback) {\n\t                    searchFinishCallback([]);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            var _find = (0, _treeDataUtils.find)({\n\t                getNodeKey: this.props.getNodeKey,\n\t                treeData: treeData,\n\t                searchQuery: searchQuery,\n\t                searchMethod: searchMethod || _defaultHandlers.defaultSearchMethod,\n\t                searchFocusOffset: searchFocusOffset,\n\t                expandAllMatchPaths: expand && !singleSearch,\n\t                expandFocusMatchPaths: expand && true\n\t            });\n\t\n\t            var expandedTreeData = _find.treeData;\n\t            var searchMatches = _find.matches;\n\t\n\t            // Update the tree with data leaving all paths leading to matching nodes open\n\t\n\t            if (expand) {\n\t                this.ignoreOneTreeUpdate = true; // Prevents infinite loop\n\t                onChange(expandedTreeData);\n\t            }\n\t\n\t            if (searchFinishCallback) {\n\t                searchFinishCallback(searchMatches);\n\t            }\n\t\n\t            var searchFocusTreeIndex = null;\n\t            if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {\n\t                searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n\t            }\n\t\n\t            this.setState({\n\t                searchMatches: searchMatches,\n\t                searchFocusTreeIndex: searchFocusTreeIndex\n\t            });\n\t        }\n\t    }, {\n\t        key: 'startDrag',\n\t        value: function startDrag(_ref4) {\n\t            var path = _ref4.path;\n\t\n\t            var draggingTreeData = (0, _treeDataUtils.removeNodeAtPath)({\n\t                treeData: this.props.treeData,\n\t                path: path,\n\t                getNodeKey: this.props.getNodeKey\n\t            });\n\t\n\t            this.setState({\n\t                draggingTreeData: draggingTreeData\n\t            });\n\t        }\n\t    }, {\n\t        key: 'dragHover',\n\t        value: function dragHover(_ref5) {\n\t            var draggedNode = _ref5.node;\n\t            var depth = _ref5.depth;\n\t            var minimumTreeIndex = _ref5.minimumTreeIndex;\n\t\n\t            var addedResult = (0, _treeDataUtils.insertNode)({\n\t                treeData: this.state.draggingTreeData,\n\t                newNode: draggedNode,\n\t                depth: depth,\n\t                minimumTreeIndex: minimumTreeIndex,\n\t                expandParent: true\n\t            });\n\t\n\t            var rows = this.getRows(addedResult.treeData);\n\t            var expandedParentPath = rows[addedResult.treeIndex].path;\n\t\n\t            var swapFrom = addedResult.treeIndex;\n\t            var swapTo = minimumTreeIndex;\n\t            var swapLength = 1 + (0, _treeDataUtils.getDescendantCount)({ node: draggedNode });\n\t            this.setState({\n\t                rows: (0, _genericUtils.swapRows)(rows, swapFrom, swapTo, swapLength),\n\t                swapFrom: swapFrom,\n\t                swapLength: swapLength,\n\t                swapDepth: depth,\n\t                draggingTreeData: (0, _treeDataUtils.changeNodeAtPath)({\n\t                    treeData: this.state.draggingTreeData,\n\t                    path: expandedParentPath.slice(0, -1),\n\t                    newNode: function newNode(_ref6) {\n\t                        var node = _ref6.node;\n\t                        return _extends({}, node, { expanded: true });\n\t                    },\n\t                    getNodeKey: this.props.getNodeKey\n\t                })\n\t            });\n\t        }\n\t    }, {\n\t        key: 'endDrag',\n\t        value: function endDrag(dropResult) {\n\t            if (!dropResult) {\n\t                return this.setState({\n\t                    draggingTreeData: null,\n\t                    swapFrom: null,\n\t                    swapLength: null,\n\t                    swapDepth: null,\n\t                    rows: this.getRows(this.props.treeData)\n\t                });\n\t            }\n\t\n\t            this.moveNode(dropResult);\n\t        }\n\t\n\t        /**\n\t         * Load any children in the tree that are given by a function\n\t         */\n\t\n\t    }, {\n\t        key: 'loadLazyChildren',\n\t        value: function loadLazyChildren() {\n\t            var _this2 = this;\n\t\n\t            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\t\n\t            (0, _treeDataUtils.walk)({\n\t                treeData: props.treeData,\n\t                getNodeKey: this.props.getNodeKey,\n\t                callback: function callback(_ref7) {\n\t                    var node = _ref7.node;\n\t                    var path = _ref7.path;\n\t                    var lowerSiblingCounts = _ref7.lowerSiblingCounts;\n\t                    var treeIndex = _ref7.treeIndex;\n\t\n\t                    // If the node has children defined by a function, and is either expanded\n\t                    //  or set to load even before expansion, run the function.\n\t                    if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {\n\t                        // Call the children fetching function\n\t                        node.children({\n\t                            node: node,\n\t                            path: path,\n\t                            lowerSiblingCounts: lowerSiblingCounts,\n\t                            treeIndex: treeIndex,\n\t\n\t                            // Provide a helper to append the new data when it is received\n\t                            done: function done(childrenArray) {\n\t                                return _this2.props.onChange((0, _treeDataUtils.changeNodeAtPath)({\n\t                                    treeData: _this2.props.treeData,\n\t                                    path: path,\n\t                                    newNode: function newNode(_ref8) {\n\t                                        var oldNode = _ref8.node;\n\t                                        return (\n\t                                            // Only replace the old node if it's the one we set off to find children\n\t                                            //  for in the first place\n\t                                            oldNode === node ? _extends({}, oldNode, { children: childrenArray }) : oldNode\n\t                                        );\n\t                                    },\n\t                                    getNodeKey: _this2.props.getNodeKey\n\t                                }));\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    }, {\n\t        key: 'scrollBy',\n\t        value: function scrollBy(x, y) {\n\t            if (!this.containerRef) {\n\t                return;\n\t            }\n\t\n\t            if (x !== 0) {\n\t                this.containerRef.getElementsByClassName(_reactSortableTree2.default.virtualScrollOverride)[0].scrollLeft += x;\n\t            }\n\t\n\t            if (y !== 0) {\n\t                this.scrollTop = this.scrollTop ? this.scrollTop + y : y;\n\t                this.setState({ scrollToPixel: this.scrollTop });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'render',\n\t        value: function render() {\n\t            var _this3 = this;\n\t\n\t            var _props = this.props;\n\t            var style = _props.style;\n\t            var className = _props.className;\n\t            var innerStyle = _props.innerStyle;\n\t            var rowHeight = _props.rowHeight;\n\t            var _connectDropTarget = _props._connectDropTarget;\n\t            var _state = this.state;\n\t            var rows = _state.rows;\n\t            var searchMatches = _state.searchMatches;\n\t            var searchFocusTreeIndex = _state.searchFocusTreeIndex;\n\t            var scrollToPixel = _state.scrollToPixel;\n\t\n\t            // Get indices for rows that match the search conditions\n\t\n\t            var matchKeys = {};\n\t            searchMatches.forEach(function (_ref9, i) {\n\t                var path = _ref9.path;\n\t                matchKeys[path[path.length - 1]] = i;\n\t            });\n\t\n\t            // Seek to the focused search result if there is one specified\n\t            var scrollToInfo = searchFocusTreeIndex !== null ? { scrollToIndex: searchFocusTreeIndex } : {};\n\t\n\t            return _connectDropTarget(_react2.default.createElement(\n\t                'div',\n\t                {\n\t                    className: _reactSortableTree2.default.tree + (className ? ' ' + className : ''),\n\t                    style: _extends({ height: '100%' }, style),\n\t                    ref: function ref(el) {\n\t                        _this3.containerRef = el;\n\t                    }\n\t                },\n\t                _react2.default.createElement(\n\t                    _reactVirtualized.AutoSizer,\n\t                    null,\n\t                    function (_ref10) {\n\t                        var height = _ref10.height;\n\t                        var width = _ref10.width;\n\t                        return _react2.default.createElement(_reactVirtualized.List, _extends({}, scrollToInfo, {\n\t                            scrollToAlignment: 'start',\n\t                            className: _reactSortableTree2.default.virtualScrollOverride,\n\t                            width: width,\n\t                            scrollTop: scrollToPixel,\n\t                            onScroll: function onScroll(_ref11) {\n\t                                var scrollTop = _ref11.scrollTop;\n\t                                _this3.scrollTop = scrollTop;\n\t                            },\n\t                            height: height,\n\t                            style: innerStyle,\n\t                            rowCount: rows.length,\n\t                            estimatedRowSize: rowHeight,\n\t                            rowHeight: rowHeight,\n\t                            rowRenderer: function rowRenderer(_ref12) {\n\t                                var index = _ref12.index;\n\t                                var key = _ref12.key;\n\t                                var rowStyle = _ref12.style;\n\t                                return _this3.renderRow(rows[index], index, key, rowStyle, function () {\n\t                                    return rows[index - 1] || null;\n\t                                }, matchKeys);\n\t                            }\n\t                        }, _this3.props.reactVirtualizedListProps));\n\t                    }\n\t                )\n\t            ));\n\t        }\n\t    }, {\n\t        key: 'renderRow',\n\t        value: function renderRow(_ref13, listIndex, key, style, getPrevRow, matchKeys) {\n\t            var node = _ref13.node;\n\t            var path = _ref13.path;\n\t            var lowerSiblingCounts = _ref13.lowerSiblingCounts;\n\t            var treeIndex = _ref13.treeIndex;\n\t\n\t            var NodeContentRenderer = this.nodeContentRenderer;\n\t            var nodeKey = path[path.length - 1];\n\t            var isSearchMatch = nodeKey in matchKeys;\n\t            var isSearchFocus = isSearchMatch && matchKeys[nodeKey] === this.props.searchFocusOffset;\n\t\n\t            var nodeProps = !this.props.generateNodeProps ? {} : this.props.generateNodeProps({\n\t                node: node,\n\t                path: path,\n\t                lowerSiblingCounts: lowerSiblingCounts,\n\t                treeIndex: treeIndex,\n\t                isSearchMatch: isSearchMatch,\n\t                isSearchFocus: isSearchFocus\n\t            });\n\t\n\t            return _react2.default.createElement(\n\t                _treeNode2.default,\n\t                {\n\t                    style: style,\n\t                    key: key,\n\t                    treeIndex: treeIndex,\n\t                    listIndex: listIndex,\n\t                    getPrevRow: getPrevRow,\n\t                    node: node,\n\t                    path: path,\n\t                    lowerSiblingCounts: lowerSiblingCounts,\n\t                    scaffoldBlockPxWidth: this.props.scaffoldBlockPxWidth,\n\t                    swapFrom: this.state.swapFrom,\n\t                    swapLength: this.state.swapLength,\n\t                    swapDepth: this.state.swapDepth,\n\t                    maxDepth: this.props.maxDepth,\n\t                    dragHover: this.dragHover\n\t                },\n\t                _react2.default.createElement(NodeContentRenderer, _extends({\n\t                    node: node,\n\t                    path: path,\n\t                    isSearchMatch: isSearchMatch,\n\t                    isSearchFocus: isSearchFocus,\n\t                    treeIndex: treeIndex,\n\t                    startDrag: this.startDrag,\n\t                    endDrag: this.endDrag,\n\t                    toggleChildrenVisibility: this.toggleChildrenVisibility,\n\t                    scaffoldBlockPxWidth: this.props.scaffoldBlockPxWidth\n\t                }, nodeProps))\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return ReactSortableTree;\n\t}(_react.Component);\n\t\n\tReactSortableTree.propTypes = {\n\t    // Tree data in the following format:\n\t    // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n\t    // `title` is the primary label for the node\n\t    // `subtitle` is a secondary label for the node\n\t    // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n\t    // `children` is an array of child nodes belonging to the node.\n\t    treeData: _react.PropTypes.arrayOf(_react.PropTypes.object).isRequired,\n\t\n\t    // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n\t    style: _react.PropTypes.object,\n\t\n\t    // Class name for the container wrapping the tree\n\t    className: _react.PropTypes.string,\n\t\n\t    // Style applied to the inner, scrollable container (for padding, etc.)\n\t    innerStyle: _react.PropTypes.object,\n\t\n\t    // Used by react-virtualized\n\t    // Either a fixed row height (number) or a function that returns the\n\t    // height of a row given its index: `({ index: number }): number`\n\t    rowHeight: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.func]),\n\t\n\t    // Size in px of the region near the edges that initiates scrolling on dragover\n\t    slideRegionSize: _react.PropTypes.number.isRequired, // eslint-disable-line react/no-unused-prop-types\n\t\n\t    // Custom properties to hand to the react-virtualized list\n\t    // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n\t    reactVirtualizedListProps: _react.PropTypes.object,\n\t\n\t    // The width of the blocks containing the lines representing the structure of the tree.\n\t    scaffoldBlockPxWidth: _react.PropTypes.number,\n\t\n\t    // Maximum depth nodes can be inserted at. Defaults to infinite.\n\t    maxDepth: _react.PropTypes.number,\n\t\n\t    // The method used to search nodes.\n\t    // Defaults to a function that uses the `searchQuery` string to search for nodes with\n\t    // matching `title` or `subtitle` values.\n\t    // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n\t    searchMethod: _react.PropTypes.func, // eslint-disable-line react/no-unused-prop-types\n\t\n\t    // Used by the `searchMethod` to highlight and scroll to matched nodes.\n\t    // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n\t    searchQuery: _react.PropTypes.any,\n\t\n\t    // Outline the <`searchFocusOffset`>th node and scroll to it.\n\t    searchFocusOffset: _react.PropTypes.number,\n\t\n\t    // Get the nodes that match the search criteria. Used for counting total matches, etc.\n\t    searchFinishCallback: _react.PropTypes.func, // eslint-disable-line react/no-unused-prop-types\n\t\n\t    // Generate an object with additional props to be passed to the node renderer.\n\t    // Use this for adding buttons via the `buttons` key,\n\t    // or additional `style` / `className` settings.\n\t    generateNodeProps: _react.PropTypes.func,\n\t\n\t    // Override the default component for rendering nodes (but keep the scaffolding generator)\n\t    // This is an advanced option for complete customization of the appearance.\n\t    // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n\t    nodeContentRenderer: _react.PropTypes.any,\n\t\n\t    // Determine the unique key used to identify each node and\n\t    // generate the `path` array passed in callbacks.\n\t    // By default, returns the index in the tree (omitting hidden nodes).\n\t    getNodeKey: _react.PropTypes.func,\n\t\n\t    // Called whenever tree data changed.\n\t    // Just like with React input elements, you have to update your\n\t    // own component's data to see the changes reflected.\n\t    onChange: _react.PropTypes.func.isRequired,\n\t\n\t    // Called after node move operation.\n\t    onMoveNode: _react.PropTypes.func,\n\t\n\t    // Called after children nodes collapsed or expanded.\n\t    onVisibilityToggle: _react.PropTypes.func,\n\t\n\t    // Injected by react-dnd\n\t    _connectDropTarget: _react.PropTypes.func.isRequired\n\t};\n\t\n\tReactSortableTree.defaultProps = {\n\t    getNodeKey: _defaultHandlers.defaultGetNodeKey,\n\t    nodeContentRenderer: _nodeRendererDefault2.default,\n\t    rowHeight: 62,\n\t    slideRegionSize: 100,\n\t    scaffoldBlockPxWidth: 44,\n\t    style: {},\n\t    innerStyle: {},\n\t    searchQuery: null\n\t};\n\t\n\texports.default = (0, _dragAndDropUtils.dndWrapRoot)(ReactSortableTree);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _react = __webpack_require__(4);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _dragAndDropUtils = __webpack_require__(6);\n\t\n\tvar _treeNode = __webpack_require__(20);\n\t\n\tvar _treeNode2 = _interopRequireDefault(_treeNode);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tvar TreeNode = function TreeNode(_ref) {\n\t    var children = _ref.children;\n\t    var listIndex = _ref.listIndex;\n\t    var swapFrom = _ref.swapFrom;\n\t    var swapLength = _ref.swapLength;\n\t    var swapDepth = _ref.swapDepth;\n\t    var scaffoldBlockPxWidth = _ref.scaffoldBlockPxWidth;\n\t    var lowerSiblingCounts = _ref.lowerSiblingCounts;\n\t    var connectDropTarget = _ref.connectDropTarget;\n\t    var isOver = _ref.isOver;\n\t    var draggedNode = _ref.draggedNode;\n\t    var canDrop = _ref.canDrop;\n\t    var treeIndex = _ref.treeIndex;\n\t    var _getPrevRow = _ref.getPrevRow;\n\t    var _node = _ref.node;\n\t    var _path = _ref.path;\n\t    var _maxDepth = _ref.maxDepth;\n\t    var _dragHover = _ref.dragHover;\n\t\n\t    var otherProps = _objectWithoutProperties(_ref, ['children', 'listIndex', 'swapFrom', 'swapLength', 'swapDepth', 'scaffoldBlockPxWidth', 'lowerSiblingCounts', 'connectDropTarget', 'isOver', 'draggedNode', 'canDrop', 'treeIndex', 'getPrevRow', 'node', 'path', 'maxDepth', 'dragHover']);\n\t\n\t    // Construct the scaffold representing the structure of the tree\n\t    var scaffoldBlockCount = lowerSiblingCounts.length;\n\t    var scaffold = [];\n\t    lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {\n\t        var lineClass = '';\n\t        if (lowerSiblingCount > 0) {\n\t            // At this level in the tree, the nodes had sibling nodes further down\n\t\n\t            if (listIndex === 0) {\n\t                // Top-left corner of the tree\n\t                // +-----+\n\t                // |     |\n\t                // |  +--+\n\t                // |  |  |\n\t                // +--+--+\n\t                lineClass = _treeNode2.default.lineHalfHorizontalRight + ' ' + _treeNode2.default.lineHalfVerticalBottom;\n\t            } else if (i === scaffoldBlockCount - 1) {\n\t                // Last scaffold block in the row, right before the row content\n\t                // +--+--+\n\t                // |  |  |\n\t                // |  +--+\n\t                // |  |  |\n\t                // +--+--+\n\t                lineClass = _treeNode2.default.lineHalfHorizontalRight + ' ' + _treeNode2.default.lineFullVertical;\n\t            } else {\n\t                // Simply connecting the line extending down to the next sibling on this level\n\t                // +--+--+\n\t                // |  |  |\n\t                // |  |  |\n\t                // |  |  |\n\t                // +--+--+\n\t                lineClass = _treeNode2.default.lineFullVertical;\n\t            }\n\t        } else if (listIndex === 0) {\n\t            // Top-left corner of the tree, but has no siblings\n\t            // +-----+\n\t            // |     |\n\t            // |  +--+\n\t            // |     |\n\t            // +-----+\n\t            lineClass = _treeNode2.default.lineHalfHorizontalRight;\n\t        } else if (i === scaffoldBlockCount - 1) {\n\t            // The last or only node in this level of the tree\n\t            // +--+--+\n\t            // |  |  |\n\t            // |  +--+\n\t            // |     |\n\t            // +-----+\n\t            lineClass = _treeNode2.default.lineHalfVerticalTop + ' ' + _treeNode2.default.lineHalfHorizontalRight;\n\t        }\n\t\n\t        scaffold.push(_react2.default.createElement('div', {\n\t            key: 'pre_' + i,\n\t            style: { width: scaffoldBlockPxWidth },\n\t            className: _treeNode2.default.lineBlock + ' ' + lineClass\n\t        }));\n\t\n\t        if (treeIndex !== listIndex && i === swapDepth) {\n\t            // This row has been shifted, and is at the depth of\n\t            // the line pointing to the new destination\n\t            var highlightLineClass = '';\n\t\n\t            if (listIndex === swapFrom + swapLength - 1) {\n\t                // This block is on the bottom (target) line\n\t                // This block points at the target block (where the row will go when released)\n\t                highlightLineClass = _treeNode2.default.highlightBottomLeftCorner;\n\t            } else if (treeIndex === swapFrom) {\n\t                // This block is on the top (source) line\n\t                highlightLineClass = _treeNode2.default.highlightTopLeftCorner;\n\t            } else {\n\t                // This block is between the bottom and top\n\t                highlightLineClass = _treeNode2.default.highlightLineVertical;\n\t            }\n\t\n\t            scaffold.push(_react2.default.createElement('div', {\n\t                key: 'highlight_' + i,\n\t                style: {\n\t                    width: scaffoldBlockPxWidth,\n\t                    left: scaffoldBlockPxWidth * i\n\t                },\n\t                className: _treeNode2.default.absoluteLineBlock + ' ' + highlightLineClass\n\t            }));\n\t        }\n\t    });\n\t\n\t    return connectDropTarget(_react2.default.createElement(\n\t        'div',\n\t        _extends({}, otherProps, {\n\t            className: _treeNode2.default.node\n\t        }),\n\t        scaffold,\n\t        _react2.default.createElement(\n\t            'div',\n\t            {\n\t                className: _treeNode2.default.nodeContent,\n\t                style: { left: scaffoldBlockPxWidth * scaffoldBlockCount }\n\t            },\n\t            _react.Children.map(children, function (child) {\n\t                return (0, _react.cloneElement)(child, {\n\t                    isOver: isOver,\n\t                    canDrop: canDrop,\n\t                    draggedNode: draggedNode\n\t                });\n\t            })\n\t        )\n\t    ));\n\t};\n\t\n\tTreeNode.propTypes = {\n\t    treeIndex: _react.PropTypes.number.isRequired,\n\t    node: _react.PropTypes.object.isRequired,\n\t    path: _react.PropTypes.arrayOf(_react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number])).isRequired,\n\t    swapFrom: _react.PropTypes.number,\n\t    swapDepth: _react.PropTypes.number,\n\t    swapLength: _react.PropTypes.number,\n\t    scaffoldBlockPxWidth: _react.PropTypes.number.isRequired,\n\t    lowerSiblingCounts: _react.PropTypes.array.isRequired,\n\t\n\t    listIndex: _react.PropTypes.number.isRequired,\n\t    children: _react.PropTypes.node,\n\t\n\t    // Drop target\n\t    connectDropTarget: _react.PropTypes.func.isRequired,\n\t    isOver: _react.PropTypes.bool.isRequired,\n\t    canDrop: _react.PropTypes.bool.isRequired,\n\t    draggedNode: _react.PropTypes.object\n\t};\n\t\n\texports.default = (0, _dragAndDropUtils.dndWrapTarget)(TreeNode);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getIEVersion = getIEVersion;\n\t/**\n\t * Get the version of Internet Explorer in use, or undefined\n\t *\n\t * @return {?number} ieVersion - IE version as an integer, or undefined if not IE\n\t */\n\tfunction getIEVersion() {\n\t  var match = navigator.userAgent.match(/(?:MSIE |Trident\\/.*; rv:)(\\d+)/);\n\t  return match ? parseInt(match[1], 10) : undefined;\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.swapRows = swapRows;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction swapRows(rows, fromIndex, toIndex) {\n\t    var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\t\n\t    var rowsWithoutMoved = [].concat(_toConsumableArray(rows.slice(0, fromIndex)), _toConsumableArray(rows.slice(fromIndex + count)));\n\t\n\t    return [].concat(_toConsumableArray(rowsWithoutMoved.slice(0, toIndex)), _toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".ReactVirtualized__Table__headerRow{font-weight:700;text-transform:uppercase}.ReactVirtualized__Table__headerRow,.ReactVirtualized__Table__row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ReactVirtualized__Table__headerTruncatedText{display:inline-block;max-width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.ReactVirtualized__Table__headerColumn,.ReactVirtualized__Table__rowColumn{margin-right:10px;min-width:0}.ReactVirtualized__Table__rowColumn{text-overflow:ellipsis;white-space:nowrap}.ReactVirtualized__Table__headerColumn:first-of-type,.ReactVirtualized__Table__rowColumn:first-of-type{margin-left:10px}.ReactVirtualized__Table__sortableHeaderColumn{cursor:pointer}.ReactVirtualized__Table__sortableHeaderIconContainer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ReactVirtualized__Table__sortableHeaderIcon{-webkit-box-flex:0;-ms-flex:0 0 24px;flex:0 0 24px;height:1em;width:1em;fill:currentColor}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".rst__rowWrapper{padding:10px 10px 10px 0;height:100%}.rst__row{height:100%;white-space:nowrap;display:-webkit-box;display:-ms-flexbox;display:flex}.rst__rowCancelPad,.rst__rowLandingPad{border:none!important;box-shadow:none!important;outline:none!important}.rst__rowCancelPad *,.rst__rowLandingPad *{opacity:0!important}.rst__rowCancelPad:before,.rst__rowLandingPad:before{background-color:#add8e6;border:3px dashed #fff;content:'';position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1}.rst__rowCancelPad:before{background-color:#e6a8ad}.rst__rowSearchMatch{outline:3px solid #0080ff}.rst__rowSearchFocus{outline:3px solid #fc6421}.rst__loadingHandle,.rst__moveHandle,.rst__rowContents,.rst__rowLabel,.rst__rowLabel_NoFlex,.rst__rowToolbar,.rst__rowToolbar_NoFlex,.rst__toolbarButton{display:inline-block;vertical-align:middle}.rst__rowContents{position:relative;height:100%;border:1px solid #bbb;border-left:none;box-shadow:0 2px 2px -2px;padding:0 5px 0 10px;border-radius:2px;min-width:230px;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;background-color:#fff}.rst__rowLabel{padding-right:20px}.rst__rowLabel,.rst__rowToolbar{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto}.rst__rowToolbar{display:-webkit-box;display:-ms-flexbox;display:flex}.rst__loadingHandle,.rst__moveHandle{height:100%;width:44px;background:#d9d9d9 url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MiIgaGVpZ2h0PSI0MiI+PGcgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9IjIuOSIgPjxwYXRoIGQ9Ik0xNCAxNS43aDE0LjQiLz48cGF0aCBkPSJNMTQgMjEuNGgxNC40Ii8+PHBhdGggZD0iTTE0IDI3LjFoMTQuNCIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%;border:1px solid #aaa;box-shadow:0 2px 2px -2px;cursor:move;border-radius:1px;z-index:1}.rst__loadingHandle{cursor:default;background:#d9d9d9}@-webkit-keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}@keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}.rst__loadingCircle{width:80%;height:80%;margin:10%;position:relative}.rst__loadingCirclePoint{width:100%;height:100%;position:absolute;left:0;top:0}.rst__loadingCirclePoint:before{content:'';display:block;margin:0 auto;width:11%;height:30%;background-color:#fff;border-radius:30%;-webkit-animation:rst__pointFade .8s infinite ease-in-out both;animation:rst__pointFade .8s infinite ease-in-out both}.rst__loadingCirclePoint:nth-of-type(1){-webkit-transform:rotate(0deg);transform:rotate(0deg)}.rst__loadingCirclePoint:nth-of-type(1):before,.rst__loadingCirclePoint:nth-of-type(7):before{-webkit-animation-delay:-.8s;animation-delay:-.8s}.rst__loadingCirclePoint:nth-of-type(2){-webkit-transform:rotate(30deg);transform:rotate(30deg)}.rst__loadingCirclePoint:nth-of-type(8){-webkit-transform:rotate(210deg);transform:rotate(210deg)}.rst__loadingCirclePoint:nth-of-type(2):before,.rst__loadingCirclePoint:nth-of-type(8):before{-webkit-animation-delay:-666.66667ms;animation-delay:-666.66667ms}.rst__loadingCirclePoint:nth-of-type(3){-webkit-transform:rotate(60deg);transform:rotate(60deg)}.rst__loadingCirclePoint:nth-of-type(9){-webkit-transform:rotate(240deg);transform:rotate(240deg)}.rst__loadingCirclePoint:nth-of-type(3):before,.rst__loadingCirclePoint:nth-of-type(9):before{-webkit-animation-delay:-.53333333s;animation-delay:-.53333333s}.rst__loadingCirclePoint:nth-of-type(4){-webkit-transform:rotate(90deg);transform:rotate(90deg)}.rst__loadingCirclePoint:nth-of-type(10){-webkit-transform:rotate(270deg);transform:rotate(270deg)}.rst__loadingCirclePoint:nth-of-type(4):before,.rst__loadingCirclePoint:nth-of-type(10):before{-webkit-animation-delay:-.4s;animation-delay:-.4s}.rst__loadingCirclePoint:nth-of-type(5){-webkit-transform:rotate(120deg);transform:rotate(120deg)}.rst__loadingCirclePoint:nth-of-type(11){-webkit-transform:rotate(300deg);transform:rotate(300deg)}.rst__loadingCirclePoint:nth-of-type(5):before,.rst__loadingCirclePoint:nth-of-type(11):before{-webkit-animation-delay:-.26666667s;animation-delay:-.26666667s}.rst__loadingCirclePoint:nth-of-type(6){-webkit-transform:rotate(150deg);transform:rotate(150deg)}.rst__loadingCirclePoint:nth-of-type(12){-webkit-transform:rotate(330deg);transform:rotate(330deg)}.rst__loadingCirclePoint:nth-of-type(6):before,.rst__loadingCirclePoint:nth-of-type(12):before{-webkit-animation-delay:-.13333333s;animation-delay:-.13333333s}.rst__loadingCirclePoint:nth-of-type(7){-webkit-transform:rotate(180deg);transform:rotate(180deg)}.rst__loadingCirclePoint:nth-of-type(13){-webkit-transform:rotate(1turn);transform:rotate(1turn)}.rst__loadingCirclePoint:nth-of-type(7):before,.rst__loadingCirclePoint:nth-of-type(13):before{-webkit-animation-delay:0ms;animation-delay:0ms}.rst__rowTitle{font-weight:700}.rst__rowTitleWithSubtitle{font-size:85%;display:block;height:.8rem}.rst__rowSubtitle{font-size:70%;line-height:1}.rst__collapseButton,.rst__expandButton,.rst__visibilityToggleButton{position:absolute;border-radius:100%;box-shadow:0 0 0 1px #000;width:16px;height:16px;top:50%;-webkit-transform:translateY(-50%) translateX(-50%);transform:translateY(-50%) translateX(-50%);cursor:pointer}.rst__collapseButton:hover:not(:active),.rst__expandButton:hover:not(:active),.rst__visibilityToggleButton:hover:not(:active){background-size:24px;height:20px;width:20px}.rst__collapseButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48L2c+Cjwvc3ZnPg==\\\") no-repeat 50%}.rst__expandButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48cGF0aCBkPSJNOSA0LjV2OSIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%}.rst__row_NoFlex:before,.rst__rowContents_NoFlex:before{content:'';display:inline-block;vertical-align:middle;height:100%}.rst__rowContents_NoFlex{display:inline-block}.rst__rowContents_NoFlex:after{content:'';display:inline-block;width:100%}.rst__rowLabel_NoFlex{width:50%}.rst__rowToolbar_NoFlex{text-align:right;width:50%}.rst__lineChildren{height:100%;display:inline-block;position:absolute}.rst__lineChildren:after{content:'';position:absolute;background-color:#000;width:1px;left:50%;bottom:0;height:10px}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"rowWrapper\": \"rst__rowWrapper\",\n\t\t\"row\": \"rst__row\",\n\t\t\"rowLandingPad\": \"rst__rowLandingPad\",\n\t\t\"rowCancelPad\": \"rst__rowCancelPad\",\n\t\t\"rowSearchMatch\": \"rst__rowSearchMatch\",\n\t\t\"rowSearchFocus\": \"rst__rowSearchFocus\",\n\t\t\"rowContents\": \"rst__rowContents\",\n\t\t\"rowLabel\": \"rst__rowLabel\",\n\t\t\"rowToolbar\": \"rst__rowToolbar\",\n\t\t\"moveHandle\": \"rst__moveHandle\",\n\t\t\"loadingHandle\": \"rst__loadingHandle\",\n\t\t\"toolbarButton\": \"rst__toolbarButton\",\n\t\t\"rowLabel_NoFlex\": \"rst__rowLabel_NoFlex\",\n\t\t\"rowToolbar_NoFlex\": \"rst__rowToolbar_NoFlex\",\n\t\t\"loadingCircle\": \"rst__loadingCircle\",\n\t\t\"loadingCirclePoint\": \"rst__loadingCirclePoint\",\n\t\t\"pointFade\": \"rst__pointFade\",\n\t\t\"rowTitle\": \"rst__rowTitle\",\n\t\t\"rowTitleWithSubtitle\": \"rst__rowTitleWithSubtitle\",\n\t\t\"rowSubtitle\": \"rst__rowSubtitle\",\n\t\t\"visibilityToggleButton\": \"rst__visibilityToggleButton\",\n\t\t\"collapseButton\": \"rst__collapseButton\",\n\t\t\"expandButton\": \"rst__expandButton\",\n\t\t\"row_NoFlex\": \"rst__row_NoFlex\",\n\t\t\"rowContents_NoFlex\": \"rst__rowContents_NoFlex\",\n\t\t\"lineChildren\": \"rst__lineChildren\"\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".rst__tree{/*! This comment keeps Sass from deleting the empty rule */}.rst__virtualScrollOverride *{box-sizing:border-box}.ReactVirtualized__Grid__innerScrollContainer{overflow:visible}.ReactVirtualized__Grid{outline:none}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"tree\": \"rst__tree\",\n\t\t\"virtualScrollOverride\": \"rst__virtualScrollOverride\"\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".rst__node{min-width:100%;white-space:nowrap}.rst__nodeContent{position:absolute;top:0;bottom:0}.rst__absoluteLineBlock,.rst__lineBlock{height:100%;position:relative;display:inline-block}.rst__absoluteLineBlock{position:absolute;top:0}.rst__lineFullVertical:after,.rst__lineHalfHorizontalRight:before,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{position:absolute;content:'';background-color:#000}.rst__lineHalfHorizontalRight:before{height:1px;top:50%;right:0;width:50%}.rst__lineFullVertical:after,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{width:1px;left:50%;top:0;height:100%}.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{top:0;height:50%}.rst__lineHalfVerticalBottom:after{top:auto;bottom:0}.rst__highlightLineVertical{z-index:3}.rst__highlightLineVertical:before{position:absolute;content:'';background-color:#36c2f6;width:8px;margin-left:-4px;left:50%;top:0;height:100%}@-webkit-keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}@keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}.rst__highlightLineVertical:after{content:'';position:absolute;height:0;margin-left:-4px;left:50%;top:0;border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid #fff;-webkit-animation:rst__arrow-pulse 1s infinite linear both;animation:rst__arrow-pulse 1s infinite linear both}.rst__highlightTopLeftCorner:before{z-index:3;content:'';position:absolute;border-top:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(50% + 4px);top:50%;margin-top:-4px;right:0;width:calc(50% + 4px)}.rst__highlightBottomLeftCorner{z-index:3}.rst__highlightBottomLeftCorner:before{content:'';position:absolute;border-bottom:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(100% + 4px);top:0;right:12px;width:calc(50% - 8px)}.rst__highlightBottomLeftCorner:after{content:'';position:absolute;height:0;right:0;top:100%;margin-top:-12px;border-top:12px solid transparent;border-bottom:12px solid transparent;border-left:12px solid #36c2f6}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"node\": \"rst__node\",\n\t\t\"nodeContent\": \"rst__nodeContent\",\n\t\t\"lineBlock\": \"rst__lineBlock\",\n\t\t\"absoluteLineBlock\": \"rst__absoluteLineBlock\",\n\t\t\"lineHalfHorizontalRight\": \"rst__lineHalfHorizontalRight\",\n\t\t\"lineFullVertical\": \"rst__lineFullVertical\",\n\t\t\"lineHalfVerticalTop\": \"rst__lineHalfVerticalTop\",\n\t\t\"lineHalfVerticalBottom\": \"rst__lineHalfVerticalBottom\",\n\t\t\"highlightLineVertical\": \"rst__highlightLineVertical\",\n\t\t\"arrow-pulse\": \"rst__arrow-pulse\",\n\t\t\"highlightTopLeftCorner\": \"rst__highlightTopLeftCorner\",\n\t\t\"highlightBottomLeftCorner\": \"rst__highlightBottomLeftCorner\"\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(13);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../css-loader/index.js!./../postcss-loader/index.js!./styles.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../css-loader/index.js!./../postcss-loader/index.js!./styles.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(14);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./node-renderer-default.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./node-renderer-default.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(15);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./react-sortable-tree.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./react-sortable-tree.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(16);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./tree-node.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./tree-node.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_21__;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_23__;\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-sortable-tree.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5efe8a9c500e9b782d22\n **/","import SortableTree from './react-sortable-tree';\n\nexport * from './utils/default-handlers';\nexport * from './utils/tree-data-utils';\nexport default SortableTree;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    node,\n    currentIndex,\n    getNodeKey,\n    path = [],\n    lowerSiblingCounts = [],\n    ignoreCollapsed = true,\n    isPseudoRoot = false,\n}) {\n    // The pseudo-root is not considered in the path\n    const selfPath = !isPseudoRoot ? [...path, getNodeKey({ node, treeIndex: currentIndex })] : [];\n\n    // Return target node when found\n    if (currentIndex === targetIndex) {\n        return {\n            node,\n            lowerSiblingCounts,\n            path: selfPath,\n        };\n    }\n\n    // Add one and continue for nodes with no children or hidden children\n    if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n        return { nextIndex: currentIndex + 1 };\n    }\n\n    // Iterate over each child and their descendants and return the\n    // target node if childIndex reaches the targetIndex\n    let childIndex   = currentIndex + 1;\n    const childCount = node.children.length;\n    for (let i = 0; i < childCount; i++) {\n        const result = getNodeDataAtTreeIndexOrNextIndex({\n            ignoreCollapsed,\n            getNodeKey,\n            targetIndex,\n            node: node.children[i],\n            currentIndex: childIndex,\n            lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\n            path: selfPath,\n        });\n\n        if (result.node) {\n            return result;\n        }\n\n        childIndex = result.nextIndex;\n    }\n\n    // If the target node is not found, return the farthest traversed index\n    return { nextIndex: childIndex };\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n    return getNodeDataAtTreeIndexOrNextIndex({\n        getNodeKey: () => {},\n        ignoreCollapsed,\n        node,\n        currentIndex: 0,\n        targetIndex:  -1,\n    }).nextIndex - 1;\n}\n\n/**\n * Walk all descendants of the given node\n */\nfunction walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot = false,\n    node,\n    currentIndex,\n    path = [],\n    lowerSiblingCounts = [],\n}) {\n    // The pseudo-root is not considered in the path\n    const selfPath = !isPseudoRoot ? [ ...path, getNodeKey({ node, treeIndex: currentIndex }) ] : [];\n    const selfInfo = !isPseudoRoot ? { node, path: selfPath, lowerSiblingCounts, treeIndex: currentIndex } : null;\n    if (!isPseudoRoot) {\n        const callbackResult = callback(selfInfo);\n\n        // Cut walk short if the callback returned false\n        if (callbackResult === false) {\n            return false;\n        }\n    }\n\n    // Return self on nodes with no children or hidden children\n    if (!node.children || (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)) {\n        return currentIndex;\n    }\n\n    // Get all descendants\n    let childIndex   = currentIndex;\n    const childCount = node.children.length;\n    if (typeof node.children !== 'function') {\n        for (let i = 0; i < childCount; i++) {\n            childIndex = walkDescendants({\n                callback,\n                getNodeKey,\n                ignoreCollapsed,\n                node: node.children[i],\n                currentIndex: childIndex + 1,\n                lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\n                path: selfPath,\n            });\n\n            // Cut walk short if the callback returned false\n            if (childIndex === false) {\n                return false;\n            }\n        }\n    }\n\n    return childIndex;\n}\n\n/**\n * Perform a change on the given node and all its descendants\n */\nfunction mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot = false,\n    node,\n    currentIndex,\n    path = [],\n    lowerSiblingCounts = [],\n}) {\n    // The pseudo-root is not considered in the path\n    const selfPath = !isPseudoRoot ? [ ...path, getNodeKey({ node, treeIndex: currentIndex }) ] : [];\n    const selfInfo = !isPseudoRoot ? { node, path: selfPath, lowerSiblingCounts, treeIndex: currentIndex } : null;\n\n    // Return self on nodes with no children or hidden children\n    if (!node.children || (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)) {\n        return {\n            treeIndex: currentIndex,\n            node: callback(selfInfo),\n        };\n    }\n\n    // Get all descendants\n    let childIndex   = currentIndex;\n    const childCount = node.children.length;\n    let newChildren  = node.children;\n    if (typeof newChildren !== 'function') {\n        newChildren = newChildren.map((child, i) => {\n            const mapResult = mapDescendants({\n                callback,\n                getNodeKey,\n                ignoreCollapsed,\n                node: child,\n                currentIndex: childIndex + 1,\n                lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\n                path: selfPath,\n            });\n            childIndex = mapResult.treeIndex;\n\n            return mapResult.node;\n        });\n    }\n\n    return {\n        node: callback({\n            ...selfInfo,\n            node: {\n                ...node,\n                children: newChildren,\n            },\n        }),\n        treeIndex: childIndex,\n    };\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n    const traverse = (node) => {\n        if (!node.children || node.expanded !== true || (typeof node.children === 'function')) {\n            return 1;\n        }\n\n        return 1 + node.children.reduce((total, currentNode) => (total + traverse(currentNode)), 0);\n    };\n\n    return treeData.reduce((total, currentNode) => total + traverse(currentNode), 0);\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({ treeData, index: targetIndex, getNodeKey }) {\n    if (!treeData || treeData.length < 1) {\n        return null;\n    }\n\n    // Call the tree traversal with a pseudo-root node\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n        targetIndex,\n        getNodeKey,\n        node: {\n            children: treeData,\n            expanded: true,\n        },\n        currentIndex: -1,\n        path: [],\n        lowerSiblingCounts: [],\n        isPseudoRoot: true,\n    });\n\n    if (result.node) {\n        return result;\n    }\n\n    return null;\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n */\nexport function walk({ treeData, getNodeKey, callback, ignoreCollapsed = true }) {\n    if (!treeData || treeData.length < 1) {\n        return;\n    }\n\n    return walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        isPseudoRoot: true,\n        node: { children: treeData },\n        currentIndex: -1,\n        path: [],\n        lowerSiblingCounts: [],\n    });\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n */\nexport function map({ treeData, getNodeKey, callback, ignoreCollapsed = true }) {\n    if (!treeData || treeData.length < 1) {\n        return [];\n    }\n\n    return mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        isPseudoRoot: true,\n        node: { children: treeData },\n        currentIndex: -1,\n        path: [],\n        lowerSiblingCounts: [],\n    }).node.children;\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n    return map({\n        treeData,\n        callback: ({ node }) => ({ ...node, expanded }),\n        getNodeKey: ({ treeIndex }) => treeIndex,\n        ignoreCollapsed: false,\n    });\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} changedTreeData - The updated tree data\n */\nexport function changeNodeAtPath({ treeData, path, newNode, getNodeKey, ignoreCollapsed = true }) {\n    const RESULT_MISS = 'RESULT_MISS';\n    const traverse = ({\n        isPseudoRoot = false,\n        node,\n        currentTreeIndex,\n        pathIndex,\n    }) => {\n        if (!isPseudoRoot && getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]) {\n            return RESULT_MISS;\n        }\n\n        if (pathIndex >= path.length - 1) {\n            // If this is the final location in the path, return its changed form\n            return typeof newNode === 'function' ? newNode({ node, treeIndex: currentTreeIndex }) : newNode;\n        } else if (!node.children) {\n            // If this node is part of the path, but has no children, return the unchanged node\n            throw new Error('Path referenced children of node with no children.');\n        }\n\n        let nextTreeIndex = currentTreeIndex + 1;\n        for (let i = 0; i < node.children.length; i++) {\n            const result = traverse({\n                node:             node.children[i],\n                currentTreeIndex: nextTreeIndex,\n                pathIndex:        pathIndex + 1,\n            });\n\n            // If the result went down the correct path\n            if (result !== RESULT_MISS) {\n                if (result) {\n                    // If the result was truthy (in this case, an object),\n                    //  pass it to the next level of recursion up\n                    return {\n                        ...node,\n                        children: [\n                            ...node.children.slice(0, i),\n                            result,\n                            ...node.children.slice(i + 1),\n                        ],\n                    };\n                }\n                // If the result was falsy (returned from the newNode function), then\n                //  delete the node from the array.\n                return {\n                    ...node,\n                    children: [\n                        ...node.children.slice(0, i),\n                        ...node.children.slice(i + 1),\n                    ],\n                };\n            }\n\n            nextTreeIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n        }\n\n        return RESULT_MISS;\n    };\n\n    // Use a pseudo-root node in the beginning traversal\n    const result = traverse({\n        node: { children: treeData },\n        currentTreeIndex: -1,\n        pathIndex: -1,\n        isPseudoRoot: true,\n    });\n\n    if (result === RESULT_MISS) {\n        throw new Error('No node found at the given path.');\n    }\n\n    return result.children;\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} changedTreeData - The updated tree data\n */\nexport function removeNodeAtPath({ treeData, path, getNodeKey, ignoreCollapsed = true }) {\n    return changeNodeAtPath({\n        treeData,\n        path,\n        getNodeKey,\n        ignoreCollapsed,\n        newNode: null, // Delete the node\n    });\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({ treeData, path, getNodeKey, ignoreCollapsed = true }) {\n    let foundNodeInfo = null;\n\n    try {\n        changeNodeAtPath({\n            treeData,\n            path,\n            getNodeKey,\n            ignoreCollapsed,\n            newNode: ({ node, treeIndex }) => {\n                foundNodeInfo = { node, treeIndex };\n                return node;\n            },\n        });\n    } catch (err) {\n        // Ignore the error -- the null return will be explanation enough\n    }\n\n    return foundNodeInfo;\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n *\n * @return {Object} result\n * @return {Object} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n    treeData,\n    newNode,\n    parentKey = null,\n    getNodeKey,\n    ignoreCollapsed = true,\n    expandParent = false,\n}) {\n    if (parentKey === null) {\n        return {\n            treeData: [ ...(treeData || []), newNode],\n            treeIndex: (treeData || []).length,\n        };\n    }\n\n    let insertedTreeIndex = null;\n    let hasBeenAdded = false;\n    const changedTreeData = map({\n        treeData,\n        getNodeKey,\n        ignoreCollapsed,\n        callback: ({ node, treeIndex, path }) => {\n            const key = path ? path[path.length - 1] : null;\n            // Return nodes that are not the parent as-is\n            if (hasBeenAdded || key !== parentKey) {\n                return node;\n            }\n            hasBeenAdded = true;\n\n            const parentNode = {\n                ...node,\n            };\n\n            if (expandParent) {\n                parentNode.expanded = true;\n            }\n\n            // If no children exist yet, just add the single newNode\n            if (!parentNode.children) {\n                insertedTreeIndex = treeIndex + 1;\n                return {\n                    ...parentNode,\n                    children: [ newNode ],\n                };\n            }\n\n            if (typeof parentNode.children === 'function') {\n                throw new Error('Cannot add to children defined by a function');\n            }\n\n            let nextTreeIndex = treeIndex + 1;\n            for (let i = 0; i < parentNode.children.length; i++) {\n                nextTreeIndex += 1 + getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\n            }\n\n            insertedTreeIndex = nextTreeIndex;\n\n            return {\n                ...parentNode,\n                children: [ ...parentNode.children, newNode ],\n            };\n        },\n    });\n\n    if (!hasBeenAdded) {\n        throw new Error('No node found with the given key.');\n    }\n\n    return {\n        treeData: changedTreeData,\n        treeIndex: insertedTreeIndex,\n    };\n}\n\nfunction addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    isPseudoRoot = false,\n    isLastChild,\n    node,\n    currentIndex,\n    currentDepth,\n}) {\n    if (currentDepth === targetDepth) {\n        return {\n            node,\n            nextIndex: currentIndex + 1 + getDescendantCount({ node, ignoreCollapsed }),\n        };\n    }\n\n    // If the current position is the only possible place to add, add it\n    if (currentIndex >= minimumTreeIndex - 1 || (isLastChild && !node.children)) {\n        if (typeof node.children === 'function') {\n            throw new Error('Cannot add to children defined by a function');\n        } else {\n            const extraNodeProps = expandParent ? { expanded: true } : {};\n            return {\n                node: {\n                    ...node,\n\n                    ...extraNodeProps,\n                    children: node.children ? [newNode, ...node.children] : [newNode],\n                },\n                nextIndex: currentIndex + 2,\n                insertedTreeIndex: currentIndex + 1,\n            };\n        }\n    }\n\n    if (currentDepth === targetDepth - 1) {\n        // Skip over nodes with no children or hidden children\n        if (!node.children ||\n            typeof node.children === 'function' ||\n            (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n        ) {\n            return { node, nextIndex: currentIndex + 1 };\n        }\n\n        let childIndex        = currentIndex + 1;\n        let insertedTreeIndex = null;\n        let insertIndex       = null;\n        for (let i = 0; i < node.children.length; i++) {\n            if (childIndex >= minimumTreeIndex) {\n                insertedTreeIndex = childIndex;\n                insertIndex = i;\n                break;\n            }\n\n            childIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n        }\n\n        if (insertIndex === null) {\n            if (childIndex < minimumTreeIndex && !isLastChild) {\n                return { node, nextIndex: childIndex };\n            }\n\n            insertedTreeIndex = childIndex;\n            insertIndex = node.children.length;\n        }\n\n        return {\n            node: {\n                ...node,\n                children: [\n                    ...node.children.slice(0, insertIndex),\n                    newNode,\n                    ...node.children.slice(insertIndex),\n                ],\n            },\n            nextIndex: childIndex,\n            insertedTreeIndex,\n        };\n    }\n\n    // Skip over nodes with no children or hidden children\n    if (!node.children ||\n        typeof node.children === 'function' ||\n        (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n        return { node, nextIndex: currentIndex + 1 };\n    }\n\n    // Get all descendants\n    let insertedTreeIndex = null;\n    let childIndex        = currentIndex + 1;\n    let newChildren       = node.children;\n    if (typeof newChildren !== 'function') {\n        newChildren = newChildren.map((child, i) => {\n            if (insertedTreeIndex !== null) {\n                return child;\n            }\n\n            const mapResult = addNodeAtDepthAndIndex({\n                targetDepth,\n                minimumTreeIndex,\n                newNode,\n                ignoreCollapsed,\n                expandParent,\n                isLastChild: isLastChild && i === newChildren.length - 1,\n                node: child,\n                currentIndex: childIndex,\n                currentDepth: currentDepth + 1,\n            });\n\n            if ('insertedTreeIndex' in mapResult) {\n                ({ insertedTreeIndex } = mapResult);\n            }\n\n            childIndex = mapResult.nextIndex;\n\n            return mapResult.node;\n        });\n    }\n\n    const result = {\n        node: { ...node, children: newChildren },\n        nextIndex: childIndex,\n    };\n\n    if (insertedTreeIndex !== null) {\n        result.insertedTreeIndex = insertedTreeIndex;\n    }\n\n    return result;\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n */\nexport function insertNode({\n    treeData,\n    depth: targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed = true,\n    expandParent = false,\n}) {\n    if (!treeData && targetDepth === 0) {\n        return {\n            treeData: [newNode],\n            treeIndex: 0,\n        };\n    }\n\n    const insertResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isPseudoRoot: true,\n        isLastChild: true,\n        node: { children: treeData },\n        currentIndex: -1,\n        currentDepth: -1,\n    });\n\n    if (!('insertedTreeIndex' in insertResult)) {\n        throw new Error('No suitable position found to insert.');\n    }\n\n    return {\n        treeData:  insertResult.node.children,\n        treeIndex: insertResult.insertedTreeIndex,\n    };\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({ treeData, getNodeKey, ignoreCollapsed = true }) {\n    if (!treeData || treeData.length < 1) {\n        return [];\n    }\n\n    const flattened = [];\n    walk({\n        treeData,\n        getNodeKey,\n        ignoreCollapsed,\n        callback: ({ node, lowerSiblingCounts, path, treeIndex }) => {\n            flattened.push({ node, lowerSiblingCounts, path, treeIndex });\n        },\n    });\n\n    return flattened;\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function} getKey - Function to get the key from the nodeData\n * @param {!function} getParentKey - Function to get the parent key from the nodeData\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n    flatData,\n    getKey,\n    getParentKey,\n    rootKey,\n}) {\n    if (!flatData) {\n        return [];\n    }\n\n    const childrenToParents = {};\n    flatData.forEach((child) => {\n        const parentKey = getParentKey(child);\n\n        if (parentKey in childrenToParents) {\n            childrenToParents[parentKey].push(child);\n        } else {\n            childrenToParents[parentKey] = [ child ];\n        }\n    });\n\n    if (!(rootKey in childrenToParents)) {\n        return [];\n    }\n\n    const trav = (parent) => {\n        const parentKey = getKey(parent);\n        if (parentKey in childrenToParents) {\n            return {\n                ...parent,\n                children: childrenToParents[parentKey].map(child => trav(child)),\n            };\n        }\n\n        return { ...parent };\n    };\n\n    return childrenToParents[rootKey].map(child => trav(child));\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n    return !!older.children && typeof older.children !== 'function' &&\n        older.children.some(child => (child === younger || isDescendant(child, younger)));\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {boolean}\n */\nexport function getDepth(node, depth = 0) {\n    if (!node.children) {\n        return depth;\n    }\n\n    if (typeof node.children === 'function') {\n        return depth + 1;\n    }\n\n    return node.children.reduce(\n        (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n        depth\n    );\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n    getNodeKey,\n    treeData,\n    searchQuery,\n    searchMethod,\n    searchFocusOffset,\n    expandAllMatchPaths = false,\n    expandFocusMatchPaths = true,\n}) {\n    let matchCount = 0;\n    const trav = ({\n        isPseudoRoot = false,\n        node,\n        currentIndex,\n        path = [],\n    }) => {\n        let matches = [];\n        let isSelfMatch = false;\n        let hasFocusMatch = false;\n        // The pseudo-root is not considered in the path\n        const selfPath = isPseudoRoot ? [] : [\n            ...path,\n            getNodeKey({ node, treeIndex: currentIndex }),\n        ];\n        const extraInfo = isPseudoRoot ? null : {\n            path: selfPath,\n            treeIndex: currentIndex,\n        };\n\n        // Nodes with with children that aren't lazy\n        const hasChildren = node.children &&\n            typeof node.children !== 'function' &&\n            node.children.length > 0;\n\n        // Examine the current node to see if it is a match\n        if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n            if (matchCount === searchFocusOffset) {\n                hasFocusMatch = true;\n            }\n\n            // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n            //  is reached\n            matchCount++;\n\n            // We cannot add this node to the matches right away, as it may be changed\n            //  during the search of the descendants. The entire node is used in\n            //  comparisons between nodes inside the `matches` and `treeData` results\n            //  of this method (`find`)\n            isSelfMatch = true;\n        }\n\n        let childIndex = currentIndex;\n        const newNode = { ...node };\n        if (hasChildren) {\n            // Get all descendants\n            newNode.children = newNode.children.map((child) => {\n                const mapResult = trav({\n                    node: child,\n                    currentIndex: childIndex + 1,\n                    path: selfPath,\n                });\n\n                // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n                // if the child is expanded.\n                //\n                // The child could have been expanded from the start,\n                // or expanded due to a matching node being found in its descendants\n                if (mapResult.node.expanded) {\n                    childIndex = mapResult.treeIndex;\n                } else {\n                    childIndex += 1;\n                }\n\n                if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n                    matches = [ ...matches, ...mapResult.matches ];\n                    if (mapResult.hasFocusMatch) {\n                        hasFocusMatch = true;\n                    }\n\n                    // Expand the current node if it has descendants matching the search\n                    // and the settings are set to do so.\n                    if ((expandAllMatchPaths && mapResult.matches.length > 0) ||\n                        ((expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch)\n                    ) {\n                        newNode.expanded = true;\n                    }\n                }\n\n                return mapResult.node;\n            });\n        }\n\n        // Cannot assign a treeIndex to hidden nodes\n        if (!isPseudoRoot && !newNode.expanded) {\n            matches = matches.map(match => ({\n                ...match,\n                treeIndex: null,\n            }));\n        }\n\n        // Add this node to the matches if it fits the search criteria.\n        // This is performed at the last minute so newNode can be sent in its final form.\n        if (isSelfMatch) {\n            matches = [\n                { ...extraInfo, node: newNode },\n                ...matches,\n            ];\n        }\n\n        return {\n            node: matches.length > 0 ? newNode : node,\n            matches,\n            hasFocusMatch,\n            treeIndex: childIndex,\n        };\n    };\n\n    const result = trav({\n        node: { children: treeData },\n        isPseudoRoot: true,\n        currentIndex: -1,\n    });\n\n    return {\n        matches: result.matches,\n        treeData: result.node.children,\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/tree-data-utils.js\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 2\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"react\"\n ** module id = 4\n ** module chunks = 0\n **/","export function defaultGetNodeKey({ node: _node, treeIndex }) {\n    return treeIndex;\n}\n\n// Cheap hack to get the text of a react object\nfunction getReactElementText(parent) {\n    if (typeof parent === 'string') {\n        return parent;\n    }\n\n    if (typeof parent !== 'object' ||\n        !parent.props ||\n        !parent.props.children ||\n        (typeof parent.props.children !== 'string' && typeof parent.props.children !== 'object')\n    ) {\n        return '';\n    }\n\n    if (typeof parent.props.children === 'string') {\n        return parent.props.children;\n    }\n\n    return parent.props.children.map(child => getReactElementText(child)).join('');\n}\n\n// Search for a query string inside a node property\nfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n    if (typeof node[key] === 'function') {\n        return String(node[key]({ node, path, treeIndex })).indexOf(searchQuery) > -1;\n    } else if (typeof node[key] === 'object') {\n        return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n    }\n\n    return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n}\n\nexport function defaultSearchMethod({ node, path, treeIndex, searchQuery }) {\n    return stringSearch('title', searchQuery, node, path, treeIndex) ||\n        stringSearch('subtitle', searchQuery, node, path, treeIndex);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/default-handlers.js\n **/","import {\n    DragDropContext as dragDropContext,\n    DragSource as dragSource,\n    DropTarget as dropTarget,\n} from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport ItemTypes from '../item-types';\nimport {\n    getDepth,\n} from './tree-data-utils';\n\nconst nodeDragSource = {\n    beginDrag(props) {\n        props.startDrag(props);\n\n        return {\n            node: props.node,\n            path: props.path,\n        };\n    },\n\n    endDrag(props, monitor) {\n        props.endDrag(monitor.getDropResult());\n    },\n\n    isDragging(props, monitor) {\n        const dropTargetNode = monitor.getItem().node;\n        const draggedNode    = props.node;\n\n        return draggedNode === dropTargetNode;\n    }\n};\n\nfunction getTargetDepth(dropTargetProps, monitor) {\n    let dropTargetDepth = 0;\n    const draggedItem = monitor.getItem();\n    const rowAbove = dropTargetProps.getPrevRow();\n    if (rowAbove) {\n        // Limit the length of the path to the deepest possible\n        dropTargetDepth = Math.min(rowAbove.path.length, dropTargetProps.path.length);\n    }\n\n    const blocksOffset = Math.round(\n        monitor.getDifferenceFromInitialOffset().x /\n        dropTargetProps.scaffoldBlockPxWidth\n    );\n\n    let targetDepth = Math.min(dropTargetDepth, Math.max(0, draggedItem.path.length + blocksOffset - 1));\n\n    // If a maxDepth is defined, constrain the target depth\n    if (typeof dropTargetProps.maxDepth !== 'undefined' && dropTargetProps.maxDepth !== null) {\n        const draggedNode       = monitor.getItem().node;\n        const draggedChildDepth = getDepth(draggedNode);\n\n        targetDepth = Math.min(targetDepth, dropTargetProps.maxDepth - draggedChildDepth - 1);\n    }\n\n    return targetDepth;\n}\n\nfunction canDrop(dropTargetProps, monitor, isHover = false) {\n    let abovePath      = [];\n    let aboveNode      = {};\n    const rowAbove = dropTargetProps.getPrevRow();\n    if (rowAbove) {\n        abovePath = rowAbove.path;\n        aboveNode = rowAbove.node;\n    }\n\n    const targetDepth = getTargetDepth(dropTargetProps, monitor);\n    const draggedNode = monitor.getItem().node;\n    return (\n        // Either we're not adding to the children of the row above...\n        targetDepth < abovePath.length ||\n        // ...or we guarantee it's not a function we're trying to add to\n        typeof aboveNode.children !== 'function'\n    ) && (\n        // Ignore when hovered above the identical node...\n        !(dropTargetProps.node === draggedNode && isHover === true) ||\n        // ...unless it's at a different level than the current one\n        targetDepth !== (dropTargetProps.path.length - 1)\n    );\n}\n\nconst nodeDropTarget = {\n    drop(dropTargetProps, monitor) {\n        return {\n            node:             monitor.getItem().node,\n            path:             monitor.getItem().path,\n            minimumTreeIndex: dropTargetProps.treeIndex,\n            depth:            getTargetDepth(dropTargetProps, monitor),\n        };\n    },\n\n    hover(dropTargetProps, monitor) {\n        if (!canDrop(dropTargetProps, monitor, true)) {\n            return;\n        }\n\n        dropTargetProps.dragHover({\n            node:             monitor.getItem().node,\n            path:             monitor.getItem().path,\n            minimumTreeIndex: dropTargetProps.listIndex,\n            depth:            getTargetDepth(dropTargetProps, monitor),\n        });\n    },\n\n    canDrop,\n};\n\nconst scrollDropTarget = {\n    hover(props, monitor, component) {\n        const cancelAnimationFrame = window.cancelAnimationFrame || (timeout => clearTimeout(timeout));\n        const requestAnimationFrame = window.requestAnimationFrame || (func => setTimeout(func, 1000 / 60));\n\n        // If already scrolling, stop the previous scroll loop\n        if (this.lastScroll) {\n            cancelAnimationFrame(this.lastScroll);\n            this.lastScroll = null;\n            clearTimeout(this.removeTimeout);\n        }\n\n        const slideRegionSize = component.props.slideRegionSize;\n        const { x: dragXOffset, y: dragYOffset } = monitor.getClientOffset();\n        const {\n            top:    containerTop,\n            bottom: containerBottom,\n            left:   containerLeft,\n            right:  containerRight,\n        } = component.containerRef.getBoundingClientRect();\n        let yScrollDirection = 0;\n        let yScrollMagnitude = 0;\n        const fromTop = dragYOffset - slideRegionSize - Math.max(containerTop, 0);\n        if (fromTop <= 0) {\n            // Move up\n            yScrollDirection = -1;\n            yScrollMagnitude = Math.sqrt(-1 * fromTop);\n        } else {\n            const fromBottom = dragYOffset + slideRegionSize - Math.min(containerBottom, window.innerHeight);\n            if (fromBottom >= 0) {\n                // Move down\n                yScrollDirection = 1;\n                yScrollMagnitude = Math.sqrt(fromBottom);\n            }\n        }\n\n        let xScrollDirection = 0;\n        let xScrollMagnitude = 0;\n        const fromLeft = dragXOffset - slideRegionSize - Math.max(containerLeft, 0);\n        if (fromLeft <= 0) {\n            // Move up\n            xScrollDirection = -1;\n            xScrollMagnitude = Math.ceil(Math.sqrt(-1 * fromLeft));\n        } else {\n            const fromRight = dragXOffset + slideRegionSize - Math.min(containerRight, window.innerWidth);\n            if (fromRight >= 0) {\n                // Move down\n                xScrollDirection = 1;\n                xScrollMagnitude = Math.ceil(Math.sqrt(fromRight));\n            }\n        }\n\n        // Don't do anything if there is no scroll operation\n        if (xScrollDirection === 0 && yScrollDirection === 0) {\n            return;\n        }\n\n        // Indefinitely scrolls the container at a constant rate\n        const doScroll = () => {\n            component.scrollBy(xScrollDirection * xScrollMagnitude, yScrollDirection * yScrollMagnitude);\n            this.lastScroll = requestAnimationFrame(doScroll);\n        };\n\n        // Stop the scroll loop after a period of inactivity\n        this.removeTimeout = setTimeout(() => {\n            cancelAnimationFrame(this.lastScroll);\n            this.lastScroll = null;\n        }, 20);\n\n        // Start the scroll loop\n        this.lastScroll = requestAnimationFrame(doScroll);\n    },\n\n    canDrop() {\n        return false;\n    },\n};\n\nfunction nodeDragSourcePropInjection(connect, monitor) {\n    return {\n        connectDragSource:  connect.dragSource(),\n        connectDragPreview: connect.dragPreview(),\n        isDragging:         monitor.isDragging(),\n    };\n}\n\nfunction nodeDropTargetPropInjection(connect, monitor) {\n    const dragged = monitor.getItem();\n    return {\n        connectDropTarget: connect.dropTarget(),\n        isOver:            monitor.isOver(),\n        canDrop:           monitor.canDrop(),\n        draggedNode:       dragged ? dragged.node : null,\n    };\n}\n\nfunction scrollDropTargetPropInjection(connect) {\n    return {\n        _connectDropTarget: connect.dropTarget(),\n    };\n}\n\nexport function dndWrapSource(el) {\n    return dragSource(ItemTypes.HANDLE, nodeDragSource, nodeDragSourcePropInjection)(el);\n}\n\nexport function dndWrapTarget(el) {\n    return dropTarget(ItemTypes.HANDLE, nodeDropTarget, nodeDropTargetPropInjection)(el);\n}\n\nexport function dndWrapRoot(el) {\n    return dragDropContext(HTML5Backend)(\n        dropTarget(ItemTypes.HANDLE, scrollDropTarget, scrollDropTargetPropInjection)(el)\n    );\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/drag-and-drop-utils.js\n **/","export default {\n    HANDLE: 'HANDLE',\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/item-types.js\n **/","import React, { PropTypes } from 'react';\nimport { getIEVersion } from './utils/browser-utils';\nimport baseStyles from './node-renderer-default.scss';\nimport { isDescendant } from './utils/tree-data-utils';\n\nlet styles = baseStyles;\n// Add extra classes in browsers that don't support flex\nif (getIEVersion < 10) {\n    styles = {\n        ...baseStyles,\n        row:         `${styles.row} ${styles.row_NoFlex}`,\n        rowContents: `${styles.rowContents} ${styles.rowContents_NoFlex}`,\n        rowLabel:    `${styles.rowLabel} ${styles.rowLabel_NoFlex}`,\n        rowToolbar:  `${styles.rowToolbar} ${styles.rowToolbar_NoFlex}`,\n    };\n}\n\nconst NodeRendererDefault = ({\n    scaffoldBlockPxWidth,\n    toggleChildrenVisibility,\n    connectDragPreview,\n    connectDragSource,\n    isDragging,\n    isOver,\n    canDrop,\n    node,\n    draggedNode,\n    path,\n    treeIndex,\n    isSearchMatch,\n    isSearchFocus,\n    buttons,\n    className,\n    style = {},\n}) => {\n    let handle;\n    if (typeof node.children === 'function' && node.expanded) {\n        // Show a loading symbol on the handle when the children are expanded\n        //  and yet still defined by a function (a callback to fetch the children)\n        handle = (\n            <div className={styles.loadingHandle}>\n                <div className={styles.loadingCircle}>\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                    <div className={styles.loadingCirclePoint} />\n                </div>\n            </div>\n        );\n    } else {\n        // Show the handle used to initiate a drag-and-drop\n        handle = connectDragSource((\n            <div className={styles.moveHandle} />\n        ), { dropEffect: 'copy' });\n    }\n\n    const isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);\n\n    return (\n        <div style={{ height: '100%' }}>\n            {toggleChildrenVisibility && node.children && node.children.length > 0 && (\n                <div>\n                    <div\n                        className={node.expanded ? styles.collapseButton : styles.expandButton}\n                        style={{ left: -0.5 * scaffoldBlockPxWidth }}\n                        onClick={() => toggleChildrenVisibility({node, path, treeIndex})}\n                    />\n\n                    {node.expanded && !isDragging &&\n                        <div\n                            style={{ width: scaffoldBlockPxWidth }}\n                            className={styles.lineChildren}\n                        />\n                    }\n                </div>\n            )}\n\n            <div className={styles.rowWrapper}>\n                {/* Set the row preview to be used during drag and drop */}\n                {connectDragPreview(\n                    <div\n                        className={styles.row +\n                            (isDragging && isOver ? ` ${styles.rowLandingPad}` : '') +\n                            (isDragging && !isOver && canDrop ? ` ${styles.rowCancelPad}` : '') +\n                            (isSearchMatch ? ` ${styles.rowSearchMatch}` : '') +\n                            (isSearchFocus ? ` ${styles.rowSearchFocus}` : '') +\n                            (className ? ` ${className}` : '')\n                        }\n                        style={{\n                            opacity: isDraggedDescendant ? 0.5 : 1,\n                            ...style,\n                        }}\n                    >\n                        {handle}\n\n                        <div className={styles.rowContents}>\n                            <div className={styles.rowLabel}>\n                                <span\n                                    className={styles.rowTitle +\n                                        (node.subtitle ? ` ${styles.rowTitleWithSubtitle}` : '')\n                                    }\n                                >\n                                    {typeof node.title === 'function' ?\n                                        node.title({node, path, treeIndex }) :\n                                        node.title\n                                    }\n                                </span>\n\n                                {node.subtitle &&\n                                    <span className={styles.rowSubtitle}>\n                                        {typeof node.subtitle === 'function' ?\n                                            node.subtitle({node, path, treeIndex }) :\n                                            node.subtitle\n                                        }\n                                    </span>\n                                }\n                            </div>\n\n                            <div className={styles.rowToolbar}>\n                                {buttons && buttons.map((btn, index) => (\n                                    <div key={index} className={styles.toolbarButton}>\n                                        {btn}\n                                    </div>\n                                ))}\n                            </div>\n                        </div>\n                    </div>\n                )}\n            </div>\n        </div>\n    );\n};\n\nNodeRendererDefault.propTypes = {\n    node:          PropTypes.object.isRequired,\n    path:          PropTypes.arrayOf(PropTypes.oneOfType([ PropTypes.string, PropTypes.number ])).isRequired,\n    treeIndex:     PropTypes.number.isRequired,\n    isSearchMatch: PropTypes.bool,\n    isSearchFocus: PropTypes.bool,\n\n    scaffoldBlockPxWidth:     PropTypes.number.isRequired,\n    toggleChildrenVisibility: PropTypes.func,\n    buttons:                  PropTypes.arrayOf(PropTypes.node),\n    className:                PropTypes.string,\n    style:                    PropTypes.object,\n\n    // Drag and drop API functions\n    // Drag source\n    connectDragPreview: PropTypes.func.isRequired,\n    connectDragSource:  PropTypes.func.isRequired,\n    isDragging:         PropTypes.bool.isRequired,\n    draggedNode:        PropTypes.object,\n    // Drop target\n    isOver:  PropTypes.bool.isRequired,\n    canDrop: PropTypes.bool.isRequired,\n};\n\nexport default NodeRendererDefault;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/node-renderer-default.js\n **/","/*!\n * react-sortable-tree\n * Copyright 2016 Chris Fritz All rights reserved.\n * @license Open source under the MIT License\n */\n\nimport React, { Component, PropTypes } from 'react';\nimport { AutoSizer, List } from 'react-virtualized';\nimport isEqual from 'lodash.isequal';\nimport 'react-virtualized/styles.css';\nimport TreeNode from './tree-node';\nimport NodeRendererDefault from './node-renderer-default';\nimport {\n    walk,\n    getFlatDataFromTree,\n    changeNodeAtPath,\n    removeNodeAtPath,\n    insertNode,\n    getDescendantCount,\n    find,\n} from './utils/tree-data-utils';\nimport {\n    swapRows,\n} from './utils/generic-utils';\nimport {\n    defaultGetNodeKey,\n    defaultSearchMethod,\n} from './utils/default-handlers';\nimport {\n    dndWrapRoot,\n    dndWrapSource,\n} from './utils/drag-and-drop-utils';\nimport styles from './react-sortable-tree.scss';\n\nclass ReactSortableTree extends Component {\n    constructor(props) {\n        super(props);\n\n        this.nodeContentRenderer = dndWrapSource(props.nodeContentRenderer);\n\n        this.state = {\n            draggingTreeData: null,\n            swapFrom: null,\n            swapLength: null,\n            swapDepth: null,\n            rows: this.getRows(props.treeData),\n            searchMatches: [],\n            searchFocusTreeIndex: null,\n            scrollToPixel: null,\n        };\n\n        this.toggleChildrenVisibility = this.toggleChildrenVisibility.bind(this);\n        this.moveNode  = this.moveNode.bind(this);\n        this.startDrag = this.startDrag.bind(this);\n        this.dragHover = this.dragHover.bind(this);\n        this.endDrag   = this.endDrag.bind(this);\n    }\n\n    componentWillMount() {\n        this.loadLazyChildren();\n        this.search(this.props, false, false);\n        this.ignoreOneTreeUpdate = false;\n    }\n\n    toggleChildrenVisibility({ node: targetNode, path, treeIndex: _treeIndex }) {\n        const treeData = changeNodeAtPath({\n            treeData: this.props.treeData,\n            path,\n            newNode: ({ node }) => ({ ...node, expanded: !node.expanded }),\n            getNodeKey: this.props.getNodeKey,\n        });\n\n        this.props.onChange(treeData);\n\n        if (this.props.onVisibilityToggle) {\n            this.props.onVisibilityToggle({\n                treeData,\n                node: targetNode,\n                expanded: !targetNode.expanded,\n            });\n        }\n    }\n\n    moveNode({ node, depth, minimumTreeIndex }) {\n        const treeData = insertNode({\n            treeData: this.state.draggingTreeData,\n            newNode: node,\n            depth,\n            minimumTreeIndex,\n            expandParent: true,\n        }).treeData;\n\n        this.props.onChange(treeData);\n\n        if (this.props.onMoveNode) {\n            this.props.onMoveNode({ treeData, node });\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        this.setState({ searchFocusTreeIndex: null });\n        if (this.props.treeData !== nextProps.treeData) {\n            // Ignore updates caused by search, in order to avoid infinite looping\n            if (this.ignoreOneTreeUpdate) {\n                this.ignoreOneTreeUpdate = false;\n            } else {\n                this.loadLazyChildren(nextProps);\n                // Load any children defined by a function\n                this.search(nextProps, false, false);\n            }\n\n            // Calculate the rows to be shown from the new tree data\n            this.setState({\n                draggingTreeData: null,\n                swapFrom: null,\n                swapLength: null,\n                swapDepth: null,\n                rows: this.getRows(nextProps.treeData),\n            });\n        } else if (!isEqual(this.props.searchQuery, nextProps.searchQuery)) {\n            this.search(nextProps);\n        } else if (this.props.searchFocusOffset !== nextProps.searchFocusOffset) {\n            this.search(nextProps, true, true, true);\n        }\n    }\n\n    getRows(treeData) {\n        return getFlatDataFromTree({\n            ignoreCollapsed: true,\n            getNodeKey: this.props.getNodeKey,\n            treeData,\n        });\n    }\n\n    search(props = this.props, seekIndex = true, expand = true, singleSearch = false) {\n        const {\n            treeData,\n            onChange,\n            searchFinishCallback,\n            searchQuery,\n            searchMethod,\n            searchFocusOffset,\n        } = props;\n\n        // Skip search if no conditions are specified\n        if ((searchQuery === null || typeof searchQuery === 'undefined' || String(searchQuery) === '') &&\n            !searchMethod\n        ) {\n            this.setState({\n                searchMatches: [],\n            });\n\n            if (searchFinishCallback) {\n                searchFinishCallback([]);\n            }\n\n            return;\n        }\n\n        const {\n            treeData: expandedTreeData,\n            matches: searchMatches,\n        } = find({\n            getNodeKey: this.props.getNodeKey,\n            treeData,\n            searchQuery,\n            searchMethod: searchMethod || defaultSearchMethod,\n            searchFocusOffset,\n            expandAllMatchPaths: expand && !singleSearch,\n            expandFocusMatchPaths: expand && true,\n        });\n\n        // Update the tree with data leaving all paths leading to matching nodes open\n        if (expand) {\n            this.ignoreOneTreeUpdate = true; // Prevents infinite loop\n            onChange(expandedTreeData);\n        }\n\n        if (searchFinishCallback) {\n            searchFinishCallback(searchMatches);\n        }\n\n        let searchFocusTreeIndex = null;\n        if (seekIndex &&\n            searchFocusOffset !== null &&\n            searchFocusOffset < searchMatches.length\n        ) {\n            searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n        }\n\n        this.setState({\n            searchMatches,\n            searchFocusTreeIndex,\n        });\n    }\n\n    startDrag({ path }) {\n        const draggingTreeData = removeNodeAtPath({\n            treeData: this.props.treeData,\n            path,\n            getNodeKey: this.props.getNodeKey,\n        });\n\n        this.setState({\n            draggingTreeData,\n        });\n    }\n\n    dragHover({ node: draggedNode, depth, minimumTreeIndex }) {\n        const addedResult = insertNode({\n            treeData: this.state.draggingTreeData,\n            newNode: draggedNode,\n            depth,\n            minimumTreeIndex,\n            expandParent: true,\n        });\n\n        const rows               = this.getRows(addedResult.treeData);\n        const expandedParentPath = rows[addedResult.treeIndex].path;\n\n        const swapFrom   = addedResult.treeIndex;\n        const swapTo     = minimumTreeIndex;\n        const swapLength = 1 + getDescendantCount({ node: draggedNode });\n        this.setState({\n            rows: swapRows(rows, swapFrom, swapTo, swapLength),\n            swapFrom,\n            swapLength,\n            swapDepth: depth,\n            draggingTreeData: changeNodeAtPath({\n                treeData: this.state.draggingTreeData,\n                path: expandedParentPath.slice(0, -1),\n                newNode: ({ node }) => ({ ...node, expanded: true }),\n                getNodeKey: this.props.getNodeKey,\n            }),\n        });\n    }\n\n    endDrag(dropResult) {\n        if (!dropResult) {\n            return this.setState({\n                draggingTreeData: null,\n                swapFrom: null,\n                swapLength: null,\n                swapDepth: null,\n                rows: this.getRows(this.props.treeData),\n            });\n        }\n\n        this.moveNode(dropResult);\n    }\n\n    /**\n     * Load any children in the tree that are given by a function\n     */\n    loadLazyChildren(props = this.props) {\n        walk({\n            treeData: props.treeData,\n            getNodeKey: this.props.getNodeKey,\n            callback: ({ node, path, lowerSiblingCounts, treeIndex }) => {\n                // If the node has children defined by a function, and is either expanded\n                //  or set to load even before expansion, run the function.\n                if (node.children &&\n                    typeof node.children === 'function' &&\n                    (node.expanded || props.loadCollapsedLazyChildren)\n                ) {\n                    // Call the children fetching function\n                    node.children({\n                        node,\n                        path,\n                        lowerSiblingCounts,\n                        treeIndex,\n\n                        // Provide a helper to append the new data when it is received\n                        done: childrenArray => this.props.onChange(changeNodeAtPath({\n                            treeData: this.props.treeData,\n                            path,\n                            newNode: ({ node: oldNode }) => (\n                                // Only replace the old node if it's the one we set off to find children\n                                //  for in the first place\n                                oldNode === node ? { ...oldNode, children: childrenArray } : oldNode\n                            ),\n                            getNodeKey: this.props.getNodeKey,\n                        })),\n                    });\n                }\n            },\n        });\n    }\n\n    scrollBy(x, y) {\n        if (!this.containerRef) {\n            return;\n        }\n\n        if (x !== 0) {\n            this.containerRef.getElementsByClassName(styles.virtualScrollOverride)[0].scrollLeft += x;\n        }\n\n        if (y !== 0) {\n            this.scrollTop = this.scrollTop ? (this.scrollTop + y) : y;\n            this.setState({ scrollToPixel: this.scrollTop });\n        }\n    }\n\n    render() {\n        const {\n            style,\n            className,\n            innerStyle,\n            rowHeight,\n            _connectDropTarget,\n        } = this.props;\n        const {\n            rows,\n            searchMatches,\n            searchFocusTreeIndex,\n            scrollToPixel,\n        } = this.state;\n\n        // Get indices for rows that match the search conditions\n        const matchKeys = {};\n        searchMatches.forEach(({ path }, i) => { matchKeys[path[path.length - 1]] = i; });\n\n        // Seek to the focused search result if there is one specified\n        const scrollToInfo = searchFocusTreeIndex !== null ? { scrollToIndex: searchFocusTreeIndex } : {};\n\n        return _connectDropTarget(\n            <div\n                className={styles.tree + (className ? ` ${className}` : '')}\n                style={{ height: '100%', ...style }}\n                ref={(el) => { this.containerRef = el; }}\n            >\n                <AutoSizer>\n                    {({height, width}) => (\n                        <List\n                            {...scrollToInfo}\n                            scrollToAlignment=\"start\"\n                            className={styles.virtualScrollOverride}\n                            width={width}\n                            scrollTop={scrollToPixel}\n                            onScroll={({ scrollTop }) => { this.scrollTop = scrollTop; }}\n                            height={height}\n                            style={innerStyle}\n                            rowCount={rows.length}\n                            estimatedRowSize={rowHeight}\n                            rowHeight={rowHeight}\n                            rowRenderer={({ index, key, style: rowStyle }) => this.renderRow(\n                                rows[index],\n                                index,\n                                key,\n                                rowStyle,\n                                () => (rows[index - 1] || null),\n                                matchKeys\n                            )}\n                            {...this.props.reactVirtualizedListProps}\n                        />\n                    )}\n                </AutoSizer>\n            </div>\n        );\n    }\n\n    renderRow({ node, path, lowerSiblingCounts, treeIndex }, listIndex, key, style, getPrevRow, matchKeys) {\n        const NodeContentRenderer = this.nodeContentRenderer;\n        const nodeKey = path[path.length - 1];\n        const isSearchMatch = nodeKey in matchKeys;\n        const isSearchFocus = isSearchMatch &&\n            matchKeys[nodeKey] === this.props.searchFocusOffset;\n\n        const nodeProps = !this.props.generateNodeProps ? {} : this.props.generateNodeProps({\n            node,\n            path,\n            lowerSiblingCounts,\n            treeIndex,\n            isSearchMatch,\n            isSearchFocus,\n        });\n\n        return (\n            <TreeNode\n                style={style}\n                key={key}\n                treeIndex={treeIndex}\n                listIndex={listIndex}\n                getPrevRow={getPrevRow}\n                node={node}\n                path={path}\n                lowerSiblingCounts={lowerSiblingCounts}\n                scaffoldBlockPxWidth={this.props.scaffoldBlockPxWidth}\n                swapFrom={this.state.swapFrom}\n                swapLength={this.state.swapLength}\n                swapDepth={this.state.swapDepth}\n                maxDepth={this.props.maxDepth}\n                dragHover={this.dragHover}\n            >\n                <NodeContentRenderer\n                    node={node}\n                    path={path}\n                    isSearchMatch={isSearchMatch}\n                    isSearchFocus={isSearchFocus}\n                    treeIndex={treeIndex}\n                    startDrag={this.startDrag}\n                    endDrag={this.endDrag}\n                    toggleChildrenVisibility={this.toggleChildrenVisibility}\n                    scaffoldBlockPxWidth={this.props.scaffoldBlockPxWidth}\n                    {...nodeProps}\n                />\n            </TreeNode>\n        );\n    }\n}\n\nReactSortableTree.propTypes = {\n    // Tree data in the following format:\n    // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n    // `title` is the primary label for the node\n    // `subtitle` is a secondary label for the node\n    // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n    // `children` is an array of child nodes belonging to the node.\n    treeData: PropTypes.arrayOf(PropTypes.object).isRequired,\n\n    // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n    style: PropTypes.object,\n\n    // Class name for the container wrapping the tree\n    className: PropTypes.string,\n\n    // Style applied to the inner, scrollable container (for padding, etc.)\n    innerStyle: PropTypes.object,\n\n    // Used by react-virtualized\n    // Either a fixed row height (number) or a function that returns the\n    // height of a row given its index: `({ index: number }): number`\n    rowHeight: PropTypes.oneOfType([ PropTypes.number, PropTypes.func ]),\n\n    // Size in px of the region near the edges that initiates scrolling on dragover\n    slideRegionSize: PropTypes.number.isRequired, // eslint-disable-line react/no-unused-prop-types\n\n    // Custom properties to hand to the react-virtualized list\n    // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n    reactVirtualizedListProps: PropTypes.object,\n\n    // The width of the blocks containing the lines representing the structure of the tree.\n    scaffoldBlockPxWidth: PropTypes.number,\n\n    // Maximum depth nodes can be inserted at. Defaults to infinite.\n    maxDepth: PropTypes.number,\n\n    // The method used to search nodes.\n    // Defaults to a function that uses the `searchQuery` string to search for nodes with\n    // matching `title` or `subtitle` values.\n    // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n    searchMethod: PropTypes.func, // eslint-disable-line react/no-unused-prop-types\n\n    // Used by the `searchMethod` to highlight and scroll to matched nodes.\n    // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n    searchQuery: PropTypes.any,\n\n    // Outline the <`searchFocusOffset`>th node and scroll to it.\n    searchFocusOffset: PropTypes.number,\n\n    // Get the nodes that match the search criteria. Used for counting total matches, etc.\n    searchFinishCallback: PropTypes.func, // eslint-disable-line react/no-unused-prop-types\n\n    // Generate an object with additional props to be passed to the node renderer.\n    // Use this for adding buttons via the `buttons` key,\n    // or additional `style` / `className` settings.\n    generateNodeProps: PropTypes.func,\n\n    // Override the default component for rendering nodes (but keep the scaffolding generator)\n    // This is an advanced option for complete customization of the appearance.\n    // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n    nodeContentRenderer: PropTypes.any,\n\n    // Determine the unique key used to identify each node and\n    // generate the `path` array passed in callbacks.\n    // By default, returns the index in the tree (omitting hidden nodes).\n    getNodeKey: PropTypes.func,\n\n    // Called whenever tree data changed.\n    // Just like with React input elements, you have to update your\n    // own component's data to see the changes reflected.\n    onChange: PropTypes.func.isRequired,\n\n    // Called after node move operation.\n    onMoveNode: PropTypes.func,\n\n    // Called after children nodes collapsed or expanded.\n    onVisibilityToggle: PropTypes.func,\n\n    // Injected by react-dnd\n    _connectDropTarget: PropTypes.func.isRequired,\n};\n\nReactSortableTree.defaultProps = {\n    getNodeKey: defaultGetNodeKey,\n    nodeContentRenderer: NodeRendererDefault,\n    rowHeight: 62,\n    slideRegionSize: 100,\n    scaffoldBlockPxWidth: 44,\n    style: {},\n    innerStyle: {},\n    searchQuery: null,\n};\n\nexport default dndWrapRoot(ReactSortableTree);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/react-sortable-tree.js\n **/","import React, { PropTypes, Children, cloneElement } from 'react';\nimport { dndWrapTarget } from './utils/drag-and-drop-utils';\nimport styles from './tree-node.scss';\n\nconst TreeNode = ({\n    children,\n    listIndex,\n    swapFrom,\n    swapLength,\n    swapDepth,\n    scaffoldBlockPxWidth,\n    lowerSiblingCounts,\n    connectDropTarget,\n    isOver,\n    draggedNode,\n    canDrop,\n    treeIndex,\n    getPrevRow: _getPrevRow, // Delete from otherProps\n    node: _node,             // Delete from otherProps\n    path: _path,             // Delete from otherProps\n    maxDepth: _maxDepth,     // Delete from otherProps\n    dragHover: _dragHover,   // Delete from otherProps\n    ...otherProps,\n}) => {\n    // Construct the scaffold representing the structure of the tree\n    const scaffoldBlockCount = lowerSiblingCounts.length;\n    const scaffold = [];\n    lowerSiblingCounts.forEach((lowerSiblingCount, i) => {\n        let lineClass = '';\n        if (lowerSiblingCount > 0) {\n            // At this level in the tree, the nodes had sibling nodes further down\n\n            if (listIndex === 0) {\n                // Top-left corner of the tree\n                // +-----+\n                // |     |\n                // |  +--+\n                // |  |  |\n                // +--+--+\n                lineClass = `${styles.lineHalfHorizontalRight} ${styles.lineHalfVerticalBottom}`;\n            } else if (i === scaffoldBlockCount - 1) {\n                // Last scaffold block in the row, right before the row content\n                // +--+--+\n                // |  |  |\n                // |  +--+\n                // |  |  |\n                // +--+--+\n                lineClass = `${styles.lineHalfHorizontalRight} ${styles.lineFullVertical}`;\n            } else {\n                // Simply connecting the line extending down to the next sibling on this level\n                // +--+--+\n                // |  |  |\n                // |  |  |\n                // |  |  |\n                // +--+--+\n                lineClass = styles.lineFullVertical;\n            }\n        } else if (listIndex === 0) {\n            // Top-left corner of the tree, but has no siblings\n            // +-----+\n            // |     |\n            // |  +--+\n            // |     |\n            // +-----+\n            lineClass = styles.lineHalfHorizontalRight;\n        } else if (i === scaffoldBlockCount - 1) {\n            // The last or only node in this level of the tree\n            // +--+--+\n            // |  |  |\n            // |  +--+\n            // |     |\n            // +-----+\n            lineClass = `${styles.lineHalfVerticalTop} ${styles.lineHalfHorizontalRight}`;\n        }\n\n        scaffold.push(\n            <div\n                key={`pre_${i}`}\n                style={{ width: scaffoldBlockPxWidth }}\n                className={`${styles.lineBlock} ${lineClass}`}\n            />\n        );\n\n        if (treeIndex !== listIndex && i === swapDepth) {\n            // This row has been shifted, and is at the depth of\n            // the line pointing to the new destination\n            let highlightLineClass = '';\n\n            if (listIndex === swapFrom + swapLength - 1) {\n                // This block is on the bottom (target) line\n                // This block points at the target block (where the row will go when released)\n                highlightLineClass = styles.highlightBottomLeftCorner;\n            } else if (treeIndex === swapFrom) {\n                // This block is on the top (source) line\n                highlightLineClass = styles.highlightTopLeftCorner;\n            } else {\n                // This block is between the bottom and top\n                highlightLineClass = styles.highlightLineVertical;\n            }\n\n            scaffold.push(\n                <div\n                    key={`highlight_${i}`}\n                    style={{\n                        width: scaffoldBlockPxWidth,\n                        left: scaffoldBlockPxWidth * i,\n                    }}\n                    className={`${styles.absoluteLineBlock} ${highlightLineClass}`}\n                />\n            );\n        }\n    });\n\n    return connectDropTarget(\n        <div\n            {...otherProps}\n            className={styles.node}\n        >\n            {scaffold}\n\n            <div\n                className={styles.nodeContent}\n                style={{ left: scaffoldBlockPxWidth * scaffoldBlockCount }}\n            >\n                {Children.map(children, child => cloneElement(child, {\n                    isOver,\n                    canDrop,\n                    draggedNode,\n                }))}\n            </div>\n        </div>\n    );\n};\n\nTreeNode.propTypes = {\n    treeIndex:            PropTypes.number.isRequired,\n    node:                 PropTypes.object.isRequired,\n    path:                 PropTypes.arrayOf(PropTypes.oneOfType([ PropTypes.string, PropTypes.number ])).isRequired,\n    swapFrom:             PropTypes.number,\n    swapDepth:            PropTypes.number,\n    swapLength:           PropTypes.number,\n    scaffoldBlockPxWidth: PropTypes.number.isRequired,\n    lowerSiblingCounts:   PropTypes.array.isRequired,\n\n    listIndex: PropTypes.number.isRequired,\n    children:  PropTypes.node,\n\n    // Drop target\n    connectDropTarget: PropTypes.func.isRequired,\n    isOver:            PropTypes.bool.isRequired,\n    canDrop:           PropTypes.bool.isRequired,\n    draggedNode:       PropTypes.object,\n};\n\nexport default dndWrapTarget(TreeNode);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tree-node.js\n **/","/**\n * Get the version of Internet Explorer in use, or undefined\n *\n * @return {?number} ieVersion - IE version as an integer, or undefined if not IE\n */\nexport function getIEVersion() {\n    const match = navigator.userAgent.match(/(?:MSIE |Trident\\/.*; rv:)(\\d+)/);\n    return match ? parseInt(match[1], 10) : undefined;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/browser-utils.js\n **/","export function swapRows(rows, fromIndex, toIndex, count = 1) {\n    const rowsWithoutMoved = [\n        ...rows.slice(0, fromIndex),\n        ...rows.slice(fromIndex + count),\n    ];\n\n    return [\n        ...rowsWithoutMoved.slice(0, toIndex),\n        ...rows.slice(fromIndex, fromIndex + count),\n        ...rowsWithoutMoved.slice(toIndex),\n    ];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/generic-utils.js\n **/","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".ReactVirtualized__Table__headerRow{font-weight:700;text-transform:uppercase}.ReactVirtualized__Table__headerRow,.ReactVirtualized__Table__row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ReactVirtualized__Table__headerTruncatedText{display:inline-block;max-width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.ReactVirtualized__Table__headerColumn,.ReactVirtualized__Table__rowColumn{margin-right:10px;min-width:0}.ReactVirtualized__Table__rowColumn{text-overflow:ellipsis;white-space:nowrap}.ReactVirtualized__Table__headerColumn:first-of-type,.ReactVirtualized__Table__rowColumn:first-of-type{margin-left:10px}.ReactVirtualized__Table__sortableHeaderColumn{cursor:pointer}.ReactVirtualized__Table__sortableHeaderIconContainer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ReactVirtualized__Table__sortableHeaderIcon{-webkit-box-flex:0;-ms-flex:0 0 24px;flex:0 0 24px;height:1em;width:1em;fill:currentColor}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/postcss-loader!./~/react-virtualized/styles.css\n ** module id = 13\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".rst__rowWrapper{padding:10px 10px 10px 0;height:100%}.rst__row{height:100%;white-space:nowrap;display:-webkit-box;display:-ms-flexbox;display:flex}.rst__rowCancelPad,.rst__rowLandingPad{border:none!important;box-shadow:none!important;outline:none!important}.rst__rowCancelPad *,.rst__rowLandingPad *{opacity:0!important}.rst__rowCancelPad:before,.rst__rowLandingPad:before{background-color:#add8e6;border:3px dashed #fff;content:'';position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1}.rst__rowCancelPad:before{background-color:#e6a8ad}.rst__rowSearchMatch{outline:3px solid #0080ff}.rst__rowSearchFocus{outline:3px solid #fc6421}.rst__loadingHandle,.rst__moveHandle,.rst__rowContents,.rst__rowLabel,.rst__rowLabel_NoFlex,.rst__rowToolbar,.rst__rowToolbar_NoFlex,.rst__toolbarButton{display:inline-block;vertical-align:middle}.rst__rowContents{position:relative;height:100%;border:1px solid #bbb;border-left:none;box-shadow:0 2px 2px -2px;padding:0 5px 0 10px;border-radius:2px;min-width:230px;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;background-color:#fff}.rst__rowLabel{padding-right:20px}.rst__rowLabel,.rst__rowToolbar{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto}.rst__rowToolbar{display:-webkit-box;display:-ms-flexbox;display:flex}.rst__loadingHandle,.rst__moveHandle{height:100%;width:44px;background:#d9d9d9 url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MiIgaGVpZ2h0PSI0MiI+PGcgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9IjIuOSIgPjxwYXRoIGQ9Ik0xNCAxNS43aDE0LjQiLz48cGF0aCBkPSJNMTQgMjEuNGgxNC40Ii8+PHBhdGggZD0iTTE0IDI3LjFoMTQuNCIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%;border:1px solid #aaa;box-shadow:0 2px 2px -2px;cursor:move;border-radius:1px;z-index:1}.rst__loadingHandle{cursor:default;background:#d9d9d9}@-webkit-keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}@keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}.rst__loadingCircle{width:80%;height:80%;margin:10%;position:relative}.rst__loadingCirclePoint{width:100%;height:100%;position:absolute;left:0;top:0}.rst__loadingCirclePoint:before{content:'';display:block;margin:0 auto;width:11%;height:30%;background-color:#fff;border-radius:30%;-webkit-animation:rst__pointFade .8s infinite ease-in-out both;animation:rst__pointFade .8s infinite ease-in-out both}.rst__loadingCirclePoint:nth-of-type(1){-webkit-transform:rotate(0deg);transform:rotate(0deg)}.rst__loadingCirclePoint:nth-of-type(1):before,.rst__loadingCirclePoint:nth-of-type(7):before{-webkit-animation-delay:-.8s;animation-delay:-.8s}.rst__loadingCirclePoint:nth-of-type(2){-webkit-transform:rotate(30deg);transform:rotate(30deg)}.rst__loadingCirclePoint:nth-of-type(8){-webkit-transform:rotate(210deg);transform:rotate(210deg)}.rst__loadingCirclePoint:nth-of-type(2):before,.rst__loadingCirclePoint:nth-of-type(8):before{-webkit-animation-delay:-666.66667ms;animation-delay:-666.66667ms}.rst__loadingCirclePoint:nth-of-type(3){-webkit-transform:rotate(60deg);transform:rotate(60deg)}.rst__loadingCirclePoint:nth-of-type(9){-webkit-transform:rotate(240deg);transform:rotate(240deg)}.rst__loadingCirclePoint:nth-of-type(3):before,.rst__loadingCirclePoint:nth-of-type(9):before{-webkit-animation-delay:-.53333333s;animation-delay:-.53333333s}.rst__loadingCirclePoint:nth-of-type(4){-webkit-transform:rotate(90deg);transform:rotate(90deg)}.rst__loadingCirclePoint:nth-of-type(10){-webkit-transform:rotate(270deg);transform:rotate(270deg)}.rst__loadingCirclePoint:nth-of-type(4):before,.rst__loadingCirclePoint:nth-of-type(10):before{-webkit-animation-delay:-.4s;animation-delay:-.4s}.rst__loadingCirclePoint:nth-of-type(5){-webkit-transform:rotate(120deg);transform:rotate(120deg)}.rst__loadingCirclePoint:nth-of-type(11){-webkit-transform:rotate(300deg);transform:rotate(300deg)}.rst__loadingCirclePoint:nth-of-type(5):before,.rst__loadingCirclePoint:nth-of-type(11):before{-webkit-animation-delay:-.26666667s;animation-delay:-.26666667s}.rst__loadingCirclePoint:nth-of-type(6){-webkit-transform:rotate(150deg);transform:rotate(150deg)}.rst__loadingCirclePoint:nth-of-type(12){-webkit-transform:rotate(330deg);transform:rotate(330deg)}.rst__loadingCirclePoint:nth-of-type(6):before,.rst__loadingCirclePoint:nth-of-type(12):before{-webkit-animation-delay:-.13333333s;animation-delay:-.13333333s}.rst__loadingCirclePoint:nth-of-type(7){-webkit-transform:rotate(180deg);transform:rotate(180deg)}.rst__loadingCirclePoint:nth-of-type(13){-webkit-transform:rotate(1turn);transform:rotate(1turn)}.rst__loadingCirclePoint:nth-of-type(7):before,.rst__loadingCirclePoint:nth-of-type(13):before{-webkit-animation-delay:0ms;animation-delay:0ms}.rst__rowTitle{font-weight:700}.rst__rowTitleWithSubtitle{font-size:85%;display:block;height:.8rem}.rst__rowSubtitle{font-size:70%;line-height:1}.rst__collapseButton,.rst__expandButton,.rst__visibilityToggleButton{position:absolute;border-radius:100%;box-shadow:0 0 0 1px #000;width:16px;height:16px;top:50%;-webkit-transform:translateY(-50%) translateX(-50%);transform:translateY(-50%) translateX(-50%);cursor:pointer}.rst__collapseButton:hover:not(:active),.rst__expandButton:hover:not(:active),.rst__visibilityToggleButton:hover:not(:active){background-size:24px;height:20px;width:20px}.rst__collapseButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48L2c+Cjwvc3ZnPg==\\\") no-repeat 50%}.rst__expandButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48cGF0aCBkPSJNOSA0LjV2OSIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%}.rst__row_NoFlex:before,.rst__rowContents_NoFlex:before{content:'';display:inline-block;vertical-align:middle;height:100%}.rst__rowContents_NoFlex{display:inline-block}.rst__rowContents_NoFlex:after{content:'';display:inline-block;width:100%}.rst__rowLabel_NoFlex{width:50%}.rst__rowToolbar_NoFlex{text-align:right;width:50%}.rst__lineChildren{height:100%;display:inline-block;position:absolute}.rst__lineChildren:after{content:'';position:absolute;background-color:#000;width:1px;left:50%;bottom:0;height:10px}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"rowWrapper\": \"rst__rowWrapper\",\n\t\"row\": \"rst__row\",\n\t\"rowLandingPad\": \"rst__rowLandingPad\",\n\t\"rowCancelPad\": \"rst__rowCancelPad\",\n\t\"rowSearchMatch\": \"rst__rowSearchMatch\",\n\t\"rowSearchFocus\": \"rst__rowSearchFocus\",\n\t\"rowContents\": \"rst__rowContents\",\n\t\"rowLabel\": \"rst__rowLabel\",\n\t\"rowToolbar\": \"rst__rowToolbar\",\n\t\"moveHandle\": \"rst__moveHandle\",\n\t\"loadingHandle\": \"rst__loadingHandle\",\n\t\"toolbarButton\": \"rst__toolbarButton\",\n\t\"rowLabel_NoFlex\": \"rst__rowLabel_NoFlex\",\n\t\"rowToolbar_NoFlex\": \"rst__rowToolbar_NoFlex\",\n\t\"loadingCircle\": \"rst__loadingCircle\",\n\t\"loadingCirclePoint\": \"rst__loadingCirclePoint\",\n\t\"pointFade\": \"rst__pointFade\",\n\t\"rowTitle\": \"rst__rowTitle\",\n\t\"rowTitleWithSubtitle\": \"rst__rowTitleWithSubtitle\",\n\t\"rowSubtitle\": \"rst__rowSubtitle\",\n\t\"visibilityToggleButton\": \"rst__visibilityToggleButton\",\n\t\"collapseButton\": \"rst__collapseButton\",\n\t\"expandButton\": \"rst__expandButton\",\n\t\"row_NoFlex\": \"rst__row_NoFlex\",\n\t\"rowContents_NoFlex\": \"rst__rowContents_NoFlex\",\n\t\"lineChildren\": \"rst__lineChildren\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?modules&importLoaders=1&localIdentName=rst__[local]!./~/postcss-loader!./~/sass-loader!./src/node-renderer-default.scss\n ** module id = 14\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".rst__tree{/*! This comment keeps Sass from deleting the empty rule */}.rst__virtualScrollOverride *{box-sizing:border-box}.ReactVirtualized__Grid__innerScrollContainer{overflow:visible}.ReactVirtualized__Grid{outline:none}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"tree\": \"rst__tree\",\n\t\"virtualScrollOverride\": \"rst__virtualScrollOverride\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?modules&importLoaders=1&localIdentName=rst__[local]!./~/postcss-loader!./~/sass-loader!./src/react-sortable-tree.scss\n ** module id = 15\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".rst__node{min-width:100%;white-space:nowrap}.rst__nodeContent{position:absolute;top:0;bottom:0}.rst__absoluteLineBlock,.rst__lineBlock{height:100%;position:relative;display:inline-block}.rst__absoluteLineBlock{position:absolute;top:0}.rst__lineFullVertical:after,.rst__lineHalfHorizontalRight:before,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{position:absolute;content:'';background-color:#000}.rst__lineHalfHorizontalRight:before{height:1px;top:50%;right:0;width:50%}.rst__lineFullVertical:after,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{width:1px;left:50%;top:0;height:100%}.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{top:0;height:50%}.rst__lineHalfVerticalBottom:after{top:auto;bottom:0}.rst__highlightLineVertical{z-index:3}.rst__highlightLineVertical:before{position:absolute;content:'';background-color:#36c2f6;width:8px;margin-left:-4px;left:50%;top:0;height:100%}@-webkit-keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}@keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}.rst__highlightLineVertical:after{content:'';position:absolute;height:0;margin-left:-4px;left:50%;top:0;border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid #fff;-webkit-animation:rst__arrow-pulse 1s infinite linear both;animation:rst__arrow-pulse 1s infinite linear both}.rst__highlightTopLeftCorner:before{z-index:3;content:'';position:absolute;border-top:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(50% + 4px);top:50%;margin-top:-4px;right:0;width:calc(50% + 4px)}.rst__highlightBottomLeftCorner{z-index:3}.rst__highlightBottomLeftCorner:before{content:'';position:absolute;border-bottom:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(100% + 4px);top:0;right:12px;width:calc(50% - 8px)}.rst__highlightBottomLeftCorner:after{content:'';position:absolute;height:0;right:0;top:100%;margin-top:-12px;border-top:12px solid transparent;border-bottom:12px solid transparent;border-left:12px solid #36c2f6}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"node\": \"rst__node\",\n\t\"nodeContent\": \"rst__nodeContent\",\n\t\"lineBlock\": \"rst__lineBlock\",\n\t\"absoluteLineBlock\": \"rst__absoluteLineBlock\",\n\t\"lineHalfHorizontalRight\": \"rst__lineHalfHorizontalRight\",\n\t\"lineFullVertical\": \"rst__lineFullVertical\",\n\t\"lineHalfVerticalTop\": \"rst__lineHalfVerticalTop\",\n\t\"lineHalfVerticalBottom\": \"rst__lineHalfVerticalBottom\",\n\t\"highlightLineVertical\": \"rst__highlightLineVertical\",\n\t\"arrow-pulse\": \"rst__arrow-pulse\",\n\t\"highlightTopLeftCorner\": \"rst__highlightTopLeftCorner\",\n\t\"highlightBottomLeftCorner\": \"rst__highlightBottomLeftCorner\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?modules&importLoaders=1&localIdentName=rst__[local]!./~/postcss-loader!./~/sass-loader!./src/tree-node.scss\n ** module id = 16\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../css-loader/index.js!./../postcss-loader/index.js!./styles.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../css-loader/index.js!./../postcss-loader/index.js!./styles.css\", function() {\n\t\t\tvar newContent = require(\"!!./../css-loader/index.js!./../postcss-loader/index.js!./styles.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-virtualized/styles.css\n ** module id = 17\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./node-renderer-default.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./node-renderer-default.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./node-renderer-default.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/node-renderer-default.scss\n ** module id = 18\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./react-sortable-tree.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./react-sortable-tree.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./react-sortable-tree.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/react-sortable-tree.scss\n ** module id = 19\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./tree-node.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./tree-node.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js?modules&importLoaders=1&localIdentName=rst__[local]!./../node_modules/postcss-loader/index.js!./../node_modules/sass-loader/index.js!./tree-node.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/tree-node.scss\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_21__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"lodash.isequal\"\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"react-dnd\"\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_23__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"react-dnd-html5-backend\"\n ** module id = 23\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"react-virtualized\"\n ** module id = 24\n ** module chunks = 0\n **/"],"sourceRoot":""}